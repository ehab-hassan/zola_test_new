<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>Isaac Clayton</title>
	<subtitle>A cozy little corner of the web.</subtitle>
	<link href="https://ehab-hassan.github.io/zola_test_new/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://ehab-hassan.github.io/zola_test_new/"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2022-07-22T00:00:00+00:00</updated>
	<id>https://ehab-hassan.github.io/zola_test_new/atom.xml</id>
	<entry xml:lang="en">
		<title>Dealing with Cyclic Data in Rust, Part I</title>
		<published>2022-07-22T00:00:00+00:00</published>
		<updated>2022-07-22T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/blog/rust-cycles/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/blog/rust-cycles/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;Or, a &lt;em&gt;GhostCell Deep Dive&lt;&#x2F;em&gt;. &lt;&#x2F;p&gt;
&lt;p&gt;In this two-part series, we build &lt;em&gt;GhostCell&lt;&#x2F;em&gt; from first principles. In &lt;em&gt;Part I&lt;&#x2F;em&gt; we go over the underlying theory required to understand GhostCell. This post’s been sitting on my hard drive for about 9 months, so I’ve decided to bite the bullet, split what I’ve written in two, and hit publish on &lt;em&gt;Part I&lt;&#x2F;em&gt;. Hope you enjoy!&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Over the past month or so, something I’ve repeatedly run into is &lt;em&gt;GhostCell&lt;&#x2F;em&gt;, a technique that (ab)uses Rust’s lifetime system to detach ownership of data from the permission to mutate it. In short, this makes it possible to write datatypes that rely on shared interior mutability (think doubly-linked lists and other cyclical graph-like structures). In this post I wanted to explore Rust’s lifetime system to explain GhostCell from first principles, and why it’s kinda a big deal.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;on-memory-management&quot;&gt;On memory management&lt;&#x2F;h1&gt;
&lt;p&gt;One of the reasons why I find Rust interesting is interesting because it automatically manages memory at compile time, as opposed to using a garbage collector or manual memory management. At the core of this automatic memory management is Rust’s &lt;em&gt;ownership model&lt;&#x2F;em&gt;, which is a compile-time strategy that ensures &lt;em&gt;memory safety&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Memory safety boils down to two things:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;All allocated data is eventually freed once (a.k.a. deallocated, dropped).&lt;&#x2F;li&gt;
&lt;li&gt;All references to some data are gone before the data is dropped.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Garbage Collected languages ensure this property is met by scanning large portions of the heap (at runtime!) to figure out which allocations are no longer alive. Traditional systems programming languages (think C, C++, asm) offload this work to the programmer, and thus do not &lt;em&gt;ensure&lt;&#x2F;em&gt; memory safety. Breaching the contract of memory safety can lead to hard-to-track-down bugs and severe security issues.&lt;&#x2F;p&gt;
&lt;p&gt;Rust’s ownership model essentially determines the &lt;em&gt;liveness&lt;&#x2F;em&gt; of data at compile time, built on the concept of &lt;em&gt;owned&lt;&#x2F;em&gt; and &lt;em&gt;borrowed&lt;&#x2F;em&gt; data. This model ensures memory safety with little to no runtime cost—so before we get started with GhostCell, I think we should start by addressing &lt;em&gt;ownership&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;ownership&quot;&gt;Ownership&lt;&#x2F;h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;&#x2F;strong&gt; This is a deep dive, so we do start with the basics. If you’d like, you can &lt;a href=&quot;https:&#x2F;&#x2F;ehab-hassan.github.io&#x2F;zola_test_new&#x2F;blog&#x2F;rust-cycles&#x2F;#subtyping&quot;&gt;skip to the next section&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Newbies to Rust often find themselves ‘fighting the borrow checker.’ (We’ve all been there). In Rust, each bit of data has a single owner which is responsible for &lt;em&gt;dropping&lt;&#x2F;em&gt; (i.e. freeing) that data when it goes out of scope:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hi&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x owns &amp;quot;Hi&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;println!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;,&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; prints &amp;quot;Hi&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x drops &amp;quot;Hi&amp;quot; at the end of the scope
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the above, &lt;code&gt;x&lt;&#x2F;code&gt; is the owner of &lt;code&gt;&amp;quot;Hi&amp;quot;&lt;&#x2F;code&gt;, and is responsible for dropping the value when it is no longer accessible.&lt;&#x2F;p&gt;
&lt;p&gt;Rust ensures that all data has exactly one owner (there’s an asterisk here, but we’ll get into that later). The following does not compile:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hi&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x owns &amp;quot;Hi&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;                &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; ownership of &amp;quot;Hi&amp;quot; moved from x to y
&lt;&#x2F;span&gt;&lt;span&gt;println!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;,&lt;&#x2F;span&gt;&lt;span&gt; y&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; prints &amp;quot;Hi&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;println!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;,&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; ERROR: &amp;quot;Hi&amp;quot; has been moved into y!
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y drops &amp;quot;Hi&amp;quot; at the end of the scope
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;Hi&amp;quot;&lt;&#x2F;code&gt; can only have one owner: initially, this is &lt;code&gt;x&lt;&#x2F;code&gt;. When we write &lt;code&gt;let y = x&lt;&#x2F;code&gt;, we’re moving the ownership of &lt;code&gt;&amp;quot;Hi&amp;quot;&lt;&#x2F;code&gt; from &lt;code&gt;x&lt;&#x2F;code&gt; to &lt;code&gt;y&lt;&#x2F;code&gt;. That is to say, &lt;code&gt;x&lt;&#x2F;code&gt; no longer owns &lt;code&gt;&amp;quot;Hi&amp;quot;&lt;&#x2F;code&gt;. Trying to print &lt;code&gt;x&lt;&#x2F;code&gt; later is an error at compile time, because &lt;code&gt;&amp;quot;Hi&amp;quot;&lt;&#x2F;code&gt; has been &lt;em&gt;moved out of&lt;&#x2F;em&gt; &lt;code&gt;x&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;If we want both &lt;code&gt;x&lt;&#x2F;code&gt; and &lt;code&gt;y&lt;&#x2F;code&gt; to hold the string &lt;code&gt;&amp;quot;Hi&amp;quot;&lt;&#x2F;code&gt;, we could make a copy:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hi&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x owns &amp;quot;Hi&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;();      &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y owns a new copy of &amp;quot;Hi&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x drops its &amp;quot;Hi&amp;quot; at the end of the scope
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y drops its &amp;quot;Hi&amp;quot; at the end of the scope
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As its name suggests, &lt;code&gt;.clone()&lt;&#x2F;code&gt; makes a copy of some data. In the above snippet, we end up with not one heap-allocated string, but two! Although this satisfies the ownership model (each &lt;code&gt;&amp;quot;Hi&amp;quot;&lt;&#x2F;code&gt; has exactly one owner), it’s not exactly the most efficient use of space.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;aliasable-xor-mutable&quot;&gt;Aliasable XOR Mutable&lt;&#x2F;h2&gt;
&lt;p&gt;So far, we’ve been dealing with completely owned data, so let’s talk about borrowing. Rust ensures that all data is &lt;em&gt;Aliasable XOR Mutable&lt;&#x2F;em&gt; (AXM). This essentially means that:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;All data has exactly one owner.&lt;&#x2F;li&gt;
&lt;li&gt;Data may have many &lt;em&gt;immutable&lt;&#x2F;em&gt; borrows.&lt;&#x2F;li&gt;
&lt;li&gt;Data may have only one &lt;em&gt;mutable&lt;&#x2F;em&gt; borrow at any given point in time.&lt;&#x2F;li&gt;
&lt;li&gt;Data must not be borrowed mutably and immutably at the same time.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Let’s make this abstract notion a bit more concrete:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hi&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;();    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x owns &amp;quot;Hi&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;                  &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; &amp;#39;&amp;amp;x&amp;#39; immutable borrow of x held by y
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; z &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;                  &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; another immutable borrow of x held by z
&lt;&#x2F;span&gt;&lt;span&gt;println!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;{}{}{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;,&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; y&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; z&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; prints &amp;quot;HiHiHi&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y drops borrow to x, &amp;quot;Hi&amp;quot; is not dropped
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; z drops borrow to x, &amp;quot;Hi&amp;quot; is not dropped
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x drops &amp;quot;Hi&amp;quot; at the end of the scope
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the above example, &lt;code&gt;x&lt;&#x2F;code&gt; is still the owner of &lt;code&gt;&amp;quot;Hi&amp;quot;&lt;&#x2F;code&gt;. We immutably &lt;em&gt;borrow&lt;&#x2F;em&gt; &lt;code&gt;x&lt;&#x2F;code&gt; twice, in &lt;code&gt;y&lt;&#x2F;code&gt; and &lt;code&gt;z&lt;&#x2F;code&gt;. No copies of &lt;code&gt;&amp;quot;Hi&amp;quot;&lt;&#x2F;code&gt; are made, and &lt;code&gt;x&lt;&#x2F;code&gt; is responsible for cleaning up &lt;code&gt;&amp;quot;Hi&amp;quot;&lt;&#x2F;code&gt; at the end of the scope.&lt;&#x2F;p&gt;
&lt;p&gt;What happens if we try to mutate an immutable borrow?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hi&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x owns &amp;quot;Hi&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;               &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y immutably borrows x
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Bye&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;();   &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; ERROR: can&amp;#39;t mutate immutable borrow!
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y drops borrow of x, &amp;quot;Hi&amp;quot; is not dropped
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x drops &amp;quot;Hi&amp;quot; at the end of the scope
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler yells at us, of course!&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0594]: cannot assign to `*y`, which is behind a `&amp;amp;` reference
&lt;&#x2F;span&gt;&lt;span&gt; --&amp;gt; src&#x2F;main.rs:3:1
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;2 | let y = &amp;amp;x;
&lt;&#x2F;span&gt;&lt;span&gt;  |         -- help: consider changing this to be a mutable reference: `&amp;amp;mut x`
&lt;&#x2F;span&gt;&lt;span&gt;3 | *y = &amp;quot;Bye&amp;quot;.to_string();
&lt;&#x2F;span&gt;&lt;span&gt;  | ^^ `y` is a `&amp;amp;` reference, so the data it refers to cannot be written
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Obviously, one can’t mutate an immutable reference! Heeding the wisdom of the Rust compiler, let’s try converting &lt;code&gt;y&lt;&#x2F;code&gt; to a mutable reference, &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hi&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x owns &amp;quot;Hi&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;           &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y mutably borrows x
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Bye&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;();   &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; mutate &amp;quot;Hi&amp;quot; to &amp;quot;Bye&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;println!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;,&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; prints &amp;quot;Bye&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y drops borrow of x, &amp;quot;Bye&amp;quot; is not dropped
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x drops &amp;quot;Bye&amp;quot; at the end of the scope
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And compiling…&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
&lt;&#x2F;span&gt;&lt;span&gt; --&amp;gt; src&#x2F;main.rs:2:9
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;1 | let x = &amp;quot;Hi&amp;quot;.to_string();
&lt;&#x2F;span&gt;&lt;span&gt;  |     - help: consider changing this to be mutable: `mut x`
&lt;&#x2F;span&gt;&lt;span&gt;2 | let y = &amp;amp;mut x;
&lt;&#x2F;span&gt;&lt;span&gt;  |         ^^^^^^ cannot borrow as mutable
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Of course, &lt;code&gt;x&lt;&#x2F;code&gt; must be mutable to borrow it as mutable!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hi&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x mutably owns &amp;quot;Hi&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;               &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y mutably borrows x
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Bye&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;();       &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; mutate &amp;quot;Hi&amp;quot; to &amp;quot;Bye&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;println!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;,&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);            &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; prints &amp;quot;Bye&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y drops borrow of x, &amp;quot;Bye&amp;quot; is not dropped
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x drops &amp;quot;Bye&amp;quot; at the end of the scope
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This works! Just note a couple of things:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;y&lt;&#x2F;code&gt; does not need to be declared using &lt;code&gt;let mut y = ...&lt;&#x2F;code&gt; because &lt;code&gt;y&lt;&#x2F;code&gt; itself is not mutable; the reference it holds is.&lt;&#x2F;li&gt;
&lt;li&gt;Additionally, &lt;code&gt;*&lt;&#x2F;code&gt; &lt;em&gt;dereferences&lt;&#x2F;em&gt; &lt;code&gt;y&lt;&#x2F;code&gt; in &lt;code&gt;*y&lt;&#x2F;code&gt;. Dereferencing is kinda like an anti-borrow, and lets us work with the value the reference contains.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Aside:&lt;&#x2F;strong&gt; As a general rule of thumb, you can’t dereference a borrow unless you’re mutating it (like we do above), or the value is small enough to &lt;code&gt;Copy&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;What happens when we try to hold a mutable and immutable reference at the same time?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hi&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x mutably owns &amp;quot;Hi&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; w &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;                   &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; w immutably borrows x
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;               &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y mutably borrows x
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Bye&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;();       &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; mutate &amp;quot;Hi&amp;quot; to &amp;quot;Bye&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You see, because—&lt;&#x2F;p&gt;
&lt;p&gt;Wait…&lt;&#x2F;p&gt;
&lt;p&gt;Huh? This compiles? Why?&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;No, seriously, &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;amp;mode=debug&amp;amp;edition=2021&amp;amp;gist=8a5a6d68c3d2240398cd8e5d88b427dd&quot;&gt;try it yourself&lt;&#x2F;a&gt;!&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Well, Rust tries to end borrows as early as possible. Let’s write out the above again, but with the correct borrow lifetimes:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hi&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x mutably owns &amp;quot;Hi&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; w &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;                   &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; w immutably borrows x
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; w drops borrow of x, &amp;quot;Bye&amp;quot; is not dropped
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; there are no more borrows to x
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;         &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y mutably borrows x
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Bye&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; mutate &amp;quot;Hi&amp;quot; to &amp;quot;Bye&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y drops borrow of x, &amp;quot;Bye&amp;quot; is not dropped
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x drops &amp;quot;Bye&amp;quot; at the end of the scope
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see, the immutable borrow is dropped &lt;em&gt;before&lt;&#x2F;em&gt; the mutable borrow is made, so we’re actually &lt;em&gt;not&lt;&#x2F;em&gt; holding a mutable and immutable reference at the same time.&lt;&#x2F;p&gt;
&lt;p&gt;To write out the scopes and &lt;em&gt;lifetimes&lt;&#x2F;em&gt; more explicitly:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hi&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x mutably owns &amp;quot;Hi&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; w immutably borrows x
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; w drops borrow of x, &amp;quot;Bye&amp;quot; is not dropped
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;b mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;b mut&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y mutably borrows x
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Bye&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;();            &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; mutate &amp;quot;Hi&amp;quot; to &amp;quot;Bye&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y drops borrow of x, &amp;quot;Bye&amp;quot; is not dropped
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x drops &amp;quot;Bye&amp;quot; at the end of the scope
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;&#x2F;strong&gt; &lt;code&gt;&#x27;a: {&lt;&#x2F;code&gt; and &lt;code&gt;&amp;amp;&#x27;b x&lt;&#x2F;code&gt; is &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;lifetimes.html&quot;&gt;not valid syntax&lt;&#x2F;a&gt;, but it’s commonly used to show the scopes of lifetimes in Rust.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;These scopes do not overlap, so the lifetimes are &lt;em&gt;disjoint&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;“Disjoint? … Lifetimes?” I hear you thinking. “What does this have to do with anything?”&lt;&#x2F;p&gt;
&lt;p&gt;When data is borrowed, it is borrowed for a given &lt;em&gt;lifetime&lt;&#x2F;em&gt;. This is how long the borrow ‘lives’, so to speak.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lifetimes are usually denoted with a single apostrophe, like so: &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;. This notation was loosely &lt;em&gt;borrowed&lt;&#x2F;em&gt; (no pun) from OCaml, which uses &lt;code&gt;&#x27;t&lt;&#x2F;code&gt; to denote generic types.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;So in the above example, the first borrow to &lt;code&gt;x&lt;&#x2F;code&gt;, &lt;code&gt;&amp;amp;&#x27;a&lt;&#x2F;code&gt;, lasts for the lifetime &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;. Likewise, the second borrow, &lt;code&gt;&amp;amp;&#x27;b mut&lt;&#x2F;code&gt;, lasts for the lifetime &lt;code&gt;&#x27;b&#x27;&lt;&#x2F;code&gt;. Because &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; and &lt;code&gt;&#x27;b&lt;&#x2F;code&gt; do not overlap, they are &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;scope&#x2F;lifetime.html&quot;&gt;disjoint&lt;&#x2F;a&gt;. Order restored!&lt;&#x2F;p&gt;
&lt;p&gt;Borrowing is baked into Rust’s type system. If you mutably borrow a &lt;code&gt;String&lt;&#x2F;code&gt;, you do not &lt;em&gt;just&lt;&#x2F;em&gt; have a mutably borrowed &lt;code&gt;String&lt;&#x2F;code&gt;. You have an &lt;code&gt;&amp;amp;mut String&lt;&#x2F;code&gt;! The types &lt;code&gt;&amp;amp;mut String&lt;&#x2F;code&gt;, &lt;code&gt;&amp;amp;String&lt;&#x2F;code&gt;, and &lt;code&gt;String&lt;&#x2F;code&gt; are all similar, but not the same.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Aside:&lt;&#x2F;strong&gt; this is further complicated by the fact that a borrowed string is actually an &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;, not an &lt;code&gt;&amp;amp;String&lt;&#x2F;code&gt;. This is because &lt;code&gt;str&lt;&#x2F;code&gt; is a type internal to the compiler, like &lt;code&gt;usize&lt;&#x2F;code&gt;, and &lt;code&gt;String&lt;&#x2F;code&gt; is a heap-allocated container for a &lt;code&gt;str&lt;&#x2F;code&gt; that when borrowed produces an &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;These distinctions are a bit too fine-grained for what we’re &lt;em&gt;currently&lt;&#x2F;em&gt; dealing with, but it’s important to be aware that these distinctions exist.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;subtyping&quot;&gt;Subtyping&lt;&#x2F;h2&gt;
&lt;p&gt;As a matter of fact, &lt;code&gt;&amp;amp;&#x27;a String&lt;&#x2F;code&gt; and &lt;code&gt;&amp;amp;&#x27;b String&lt;&#x2F;code&gt; may actually be different types entirely, because they have different associated lifetimes!&lt;&#x2F;p&gt;
&lt;p&gt;I say ‘may’ here because it’s possible that &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; and &lt;code&gt;&#x27;b&lt;&#x2F;code&gt; overlap:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hi&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;#39;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; z &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;b&lt;&#x2F;span&gt;&lt;span&gt; y&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see, the lifetime &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; completely envelops &lt;code&gt;&#x27;b&lt;&#x2F;code&gt;. In other words, &lt;code&gt;&#x27;a: &#x27;b&lt;&#x2F;code&gt;, meaning &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; outlives &lt;code&gt;&#x27;b&lt;&#x2F;code&gt;. For this reason, &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; is a &lt;em&gt;subtype&lt;&#x2F;em&gt; of &lt;code&gt;&#x27;b&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The bigger region is a subtype of the smaller region.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Take a second to internalize this.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a large source of confusion, because it seems backwards to many: the bigger region is a subtype of the smaller region.&lt;&#x2F;p&gt;
&lt;p&gt;— &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;subtyping.html&quot;&gt;The ’Nomicon&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;code&gt;&#x27;a&lt;&#x2F;code&gt; is a subtype of &lt;code&gt;&#x27;b&lt;&#x2F;code&gt; because &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; is the same region of code, &lt;em&gt;and more&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;No, seriously, take a second to internalize this.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;If you want to learn more, I recommend you read the &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;subtyping.html&quot;&gt;&lt;em&gt;Subtyping and Variance&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; section of the Rustonomicon. If not, we’ll revisit this topic &lt;a href=&quot;subtyping-and-variance&quot;&gt;later&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;An easy way to remember this relationship is that &lt;code&gt;&#x27;static&lt;&#x2F;code&gt;, as in &lt;code&gt;&amp;amp;&#x27;static str&lt;&#x2F;code&gt;, is the subtype of &lt;em&gt;all&lt;&#x2F;em&gt; lifetimes, because &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; outlives all other lifetimes.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;an-xor-conflict&quot;&gt;An XOR Conflict!&lt;&#x2F;h2&gt;
&lt;p&gt;There’s a lot to be said about subtyping and variance, and we’ll discuss it in more depth over the coming sections. Anyway, back to our previous example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hi&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x mutably owns &amp;quot;Hi&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; w &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;                   &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; w immutably borrows x
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;               &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y mutably borrows x
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Bye&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;();       &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; mutate &amp;quot;Hi&amp;quot; to &amp;quot;Bye&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That compiles. This, however, does not:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hi&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; x mutably owns &amp;quot;Hi&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; w &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;                   &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; w immutably borrows x
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;               &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y mutably borrows x
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Bye&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;();       &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; mutate &amp;quot;Hi&amp;quot; to &amp;quot;Bye&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;println!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;,&lt;&#x2F;span&gt;&lt;span&gt; w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);            &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; ERROR: &amp;quot;Hi&amp;quot; is also borrowed as immutable!
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Originally, the lifetimes of the borrows for &lt;code&gt;w&lt;&#x2F;code&gt; and &lt;code&gt;y&lt;&#x2F;code&gt; were disjoint:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= ...;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; w &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But with the addition of &lt;code&gt;println!(&amp;quot;{}&amp;quot;, w)&lt;&#x2F;code&gt;, the scope of &lt;code&gt;w&lt;&#x2F;code&gt; is &lt;em&gt;stretched&lt;&#x2F;em&gt;, like a rubber tube, to envelop &lt;code&gt;y&lt;&#x2F;code&gt;’s scope:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= ...;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; w &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; ERROR: w is &amp;amp;x, but y is &amp;amp;mut x!
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;    println!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;,&lt;&#x2F;span&gt;&lt;span&gt; w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This does not uphold Rust’s &lt;em&gt;Aliasable XOR Mutable&lt;&#x2F;em&gt; requirement, because we’re holding an immutable borrow (in &lt;code&gt;w&lt;&#x2F;code&gt;) and a mutable borrow (in &lt;code&gt;y&lt;&#x2F;code&gt;) at the same time!&lt;&#x2F;p&gt;
&lt;h1 id=&quot;inductive-datatypes&quot;&gt;Inductive Datatypes&lt;&#x2F;h1&gt;
&lt;p&gt;With the basics of borrow checking out of the way, let’s talk data. Rust requires that all data have exactly one owner. When working with inductive datatypes (loosely anything tree-like; e.g. can easily serialize to JSON), this requirement is not much of an issue:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;User &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;    String,
&lt;&#x2F;span&gt;&lt;span&gt;    email&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;   Email,
&lt;&#x2F;span&gt;&lt;span&gt;    pw_hash&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; Hash,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;All of these fields are owned by the struct &lt;code&gt;User&lt;&#x2F;code&gt;. This makes sense: if fields were externally owned, we’d have to include the borrow in the type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;User&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    documents&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; [Document],
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As discussed earlier, when we borrow, we borrow for a lifetime. So, &lt;code&gt;&amp;amp;&#x27;a [Document]&lt;&#x2F;code&gt; has to live for at least as long as &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;. When a type is parameterized by a lifetime (e.g. &lt;code&gt;User&amp;lt;&#x27;a&amp;gt;&lt;&#x2F;code&gt;), it means that the data &lt;code&gt;User&lt;&#x2F;code&gt; contains depends on the lifetime.&lt;&#x2F;p&gt;
&lt;p&gt;In fact, you can think of &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; as a bit of a type constructor itself, like &lt;code&gt;Vec&lt;&#x2F;code&gt; or &lt;code&gt;Box&lt;&#x2F;code&gt;. &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; takes two arguments: a lifetime, like &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;, and a type &lt;code&gt;T&lt;&#x2F;code&gt; to borrow over, like a slice of documents &lt;code&gt;[Document]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;If we were to write this out using standard Rust type-constructor notation, &lt;code&gt;&amp;amp;&#x27;a T&#x27;&lt;&#x2F;code&gt; would probably look like &lt;code&gt;Borrow&amp;lt;&#x27;a, T&amp;gt;&lt;&#x2F;code&gt;. A mutable borrow, like &lt;code&gt;&amp;amp;&#x27;a mut T&lt;&#x2F;code&gt;, would be something like &lt;code&gt;BorrowMut&amp;lt;&#x27;a, T&amp;gt;&lt;&#x2F;code&gt;. Regardless of the notation used, what’s important to remember is that &lt;strong&gt;borrows can be codified as types&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Tree-like structures are easy to represent because each field in the tree has exactly one owner: the type they are a field of.&lt;&#x2F;p&gt;
&lt;p&gt;Creating arbitrary graph-like cycles is a bit harder, because each node in the graph may have multiple references, yet Rust requires (somehow), that we have only one owner per node, and that borrowing&#x2F;variance semantics are upheld.&lt;&#x2F;p&gt;
&lt;p&gt;So let’s throw caution to the wind and write some cycles in Rust:&lt;&#x2F;p&gt;
&lt;h1 id=&quot;cyclic-data&quot;&gt;Cyclic Data&lt;&#x2F;h1&gt;
&lt;p&gt;It’s can be hard to express cycles in Rust. To illustrate this point, let’s consider this naïve definition of a linked list:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Link&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    item&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; T,
&lt;&#x2F;span&gt;&lt;span&gt;    prev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Option&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;LinkRef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Option&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;LinkRef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;LinkRef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt; = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Box&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Link&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; is an owned pointer to an item of type &lt;code&gt;T&lt;&#x2F;code&gt;. This definition compiles, but if we try to use it in practice, we quickly run into some errors:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; trying to make a two-item linked list
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; initialize the first link
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; link_1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; Link &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    item&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    prev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;None&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;None&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; initialize the second link with an owned reference to the first
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; link_2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; Link &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    item&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    prev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Some&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Box&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt;new&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;link_1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)),
&lt;&#x2F;span&gt;&lt;span&gt;    next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;None&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; have the first link point to the second
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; ERROR: link_1 has already been moved into link_2!
&lt;&#x2F;span&gt;&lt;span&gt;link_1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;next &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Some&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Box&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt;new&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;link_2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The issue here is that the first link wants to own the second link, but the second link wants to own the first.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;&#x2F;strong&gt; With some careful finagling and a pinch of &lt;code&gt;std::mem&lt;&#x2F;code&gt; for good measure, you might be able to set this up without the compiler complaining (as the first node owns the second and the second owns the first, both have one owner). This is no longer the case when we move to larger lists:&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Needless to say, when you get to lists with at least three items, the middle link wants to be owned by two links: the link before it and the link after it. As this requires a single item to have two owners, this won’t fly with Rust’s borrow checker.&lt;&#x2F;p&gt;
&lt;p&gt;Perhaps there’s some way we could change the definition of &lt;code&gt;Link&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;LinkRef&lt;&#x2F;code&gt; to appease the borrow checker?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;workarounds&quot;&gt;Workarounds&lt;&#x2F;h2&gt;
&lt;p&gt;Cycles are important components for a large number of datastructures, so it’s no surprise that many techniques for creating cycles in Rust have been developed over the years.&lt;&#x2F;p&gt;
&lt;p&gt;When writing datatypes with circular references, we generally have three choices to appease the borrow checker:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Use &lt;code&gt;unsafe&lt;&#x2F;code&gt; and verify correctness ourselves.&lt;&#x2F;li&gt;
&lt;li&gt;Use another level of indirection (e.g. arena, &lt;code&gt;Vec&lt;&#x2F;code&gt; &amp;amp; handle).&lt;&#x2F;li&gt;
&lt;li&gt;Use interior mutability (&lt;code&gt;Rc&lt;&#x2F;code&gt;, &lt;code&gt;Weak&lt;&#x2F;code&gt;, &lt;code&gt;RefCell&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;GhostCell!&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Each of these above methods has its pros and cons; let’s go through each one.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;unsafe&quot;&gt;Unsafe&lt;&#x2F;h3&gt;
&lt;p&gt;While fast, &lt;code&gt;unsafe&lt;&#x2F;code&gt; is, well, unsafe. It’s easy to mess up the implementation of cyclic data structures. Using &lt;code&gt;unsafe&lt;&#x2F;code&gt;, there’s nothing to ensure that your implementation is correct.&lt;&#x2F;p&gt;
&lt;p&gt;I won’t go into &lt;code&gt;unsafe&lt;&#x2F;code&gt; now, as there will be plenty of &lt;code&gt;unsafe&lt;&#x2F;code&gt; later, but if you want a guide to writing safe linked lists and other similar datastructures in unsafe Rust, check out &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-unofficial.github.io&#x2F;too-many-lists&#x2F;&quot;&gt;&lt;em&gt;Too Many Lists&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;another-level-of-indirection&quot;&gt;Another level of indirection&lt;&#x2F;h3&gt;
&lt;p&gt;Using another level of indirection, like a typed arena, is probably the most common battle-tested technique nowadays. The traditional method of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; with a typed index handle is pretty self-explanatory:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; a typed region of memory that we manage
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;LinkArena&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    links&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Link&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; an index into that arena
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;LinkHandle &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    index&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; the link from earlier
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Link&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    item&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; T,
&lt;&#x2F;span&gt;&lt;span&gt;    prev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Option&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;LinkRef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Option&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;LinkRef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; use a link handle instead of a `Box&amp;lt;LinkRef&amp;lt;T&amp;gt;&amp;gt;`
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;LinkRef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt; =&lt;&#x2F;span&gt;&lt;span&gt; LinkHandle&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;LinkArena&lt;&#x2F;code&gt; maintains single-ownership over all data in the arena. To mutate some data in the arena, you need both a &lt;code&gt;LinkHandle&lt;&#x2F;code&gt; (which is an index into the arena), and a mutable reference to the arena itself. Because &lt;code&gt;LinkHandle&lt;&#x2F;code&gt;s are just indices, we can easily include them in our &lt;code&gt;Link&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Although simple, with this technique we lose a number of guarantees:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;We have to pass the arena around whenever we want to follow a handle.&lt;&#x2F;strong&gt; In addition, the &lt;code&gt;prev&lt;&#x2F;code&gt;ious and &lt;code&gt;next&lt;&#x2F;code&gt; items are no longer just convenient fields on the struct. This could be fixed through the use of reference-counting the arena in the handle, or an &lt;code&gt;&#x27;arena&lt;&#x2F;code&gt; lifetime. We’ll build things on top of these ideas later.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The arena holds items for longer than they may need to be held.&lt;&#x2F;strong&gt; If we remove an item, it won’t be dropped until the arena is dropped. We either have to live with this or implement garbage collection ourselves, which kinda defeats the point of a language whose whole deal is that it doesn’t need to be garbage collected.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The amortized cost is higher, because we’re using a &lt;code&gt;Vec&lt;&#x2F;code&gt; as a backing store.&lt;&#x2F;strong&gt; This requires reallocation as it grows in size, whereas just using the native heap will probably be faster. Better arenas use better backing stores (&lt;code&gt;typed-arena&lt;&#x2F;code&gt;, for instance, essentially uses a &lt;code&gt;(Vec&amp;lt;T&amp;gt;, Vec&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt;)&lt;&#x2F;code&gt; which it carefully manages).&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;All of these issues can be used by using better arenas than the above implementation. A number of crates, like &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;bumpalo&#x2F;3.8.0&#x2F;bumpalo&#x2F;&quot;&gt;&lt;code&gt;bumpalo&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;petgraph&#x2F;0.6.0&#x2F;petgraph&#x2F;&quot;&gt;&lt;code&gt;petgraph&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;slotmap&#x2F;1.0.6&#x2F;slotmap&#x2F;&quot;&gt;&lt;code&gt;slotmap&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;typed-arena&#x2F;2.0.1&#x2F;typed_arena&#x2F;&quot;&gt;&lt;code&gt;typed-arena&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;,&lt;&#x2F;p&gt;
&lt;p&gt;The most glaring issue is probably summed up by the following quote:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“All problems in computer science can be solved by another level of indirection, except for the problem of too many levels of indirection”.&lt;&#x2F;p&gt;
&lt;p&gt;— David Wheeler&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Adding an arena is another level of indirection for memory management. Think about it this way: If we allocated &lt;em&gt;everything&lt;&#x2F;em&gt; in an untyped arena, our program would &lt;code&gt;unsafe&lt;&#x2F;code&gt; by any other name.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shared-references-and-interior-mutability&quot;&gt;Shared References and Interior Mutability&lt;&#x2F;h3&gt;
&lt;p&gt;In the previous two examples, we’ve been struggling with the constraint of single ownership enforced by the Rust compiler at compile time. If data could just have multiple mutable owners, wouldn’t the whole shebang of constructing cyclical datastructures be a non-issue?&lt;&#x2F;p&gt;
&lt;p&gt;Well yes, but actually no. I’ll explain:&lt;&#x2F;p&gt;
&lt;p&gt;You see, in a single-threaded context, multiple mutable owners are perfectly acceptable, as only one write to the shared data can occur at a time. In contexts with &lt;em&gt;multiple&lt;&#x2F;em&gt; writers, however, this is no longer the case. In multithreaded contexts we run into the issue of &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Race_condition#See_also&quot;&gt;race conditions&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Time-of-check_to_time-of-use&quot;&gt;TOC&#x2F;TOU&lt;&#x2F;a&gt;: both arise when different threads try write&#x2F;read data in an uncoordinated manner. This leads to corrupted application state (at best) and segmentation faults (at worst). These types of unpredictable blow-ups are &lt;em&gt;exactly&lt;&#x2F;em&gt; the class of bugs Safe Rust is trying to prevent!&lt;&#x2F;p&gt;
&lt;p&gt;Luckily for us, Rust provides a built-in escape hatch for multiple &lt;em&gt;ownership&lt;&#x2F;em&gt; of shared data: the reference counter pointer &lt;code&gt;Rc&lt;&#x2F;code&gt;, and its multithreaded brother, the atomic reference counter &lt;code&gt;Arc&lt;&#x2F;code&gt;. In short, &lt;code&gt;Rc&lt;&#x2F;code&gt; and &lt;code&gt;Arc&lt;&#x2F;code&gt; keep track of the number of owners some data has. When the reference count reaches zero and there are no owners left, the data is dropped. Because of this, both of these reference types incur a small runtime cost in comparison to raw references.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Aside:&lt;&#x2F;strong&gt; Reference counting usually incurs &lt;strong&gt;less&lt;&#x2F;strong&gt; of a cost in Rust than in other languages. Why? Because Rust’s borrow checker is so darn smart, in many situations one can usually get away with passing around a &lt;em&gt;reference&lt;&#x2F;em&gt; to a &lt;code&gt;Rc&lt;&#x2F;code&gt;’d pointer—i.e. &lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;—rather than increasing the reference count with each call.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;code&gt;Arc&lt;&#x2F;code&gt; and &lt;code&gt;Rc&lt;&#x2F;code&gt; are only half of the story: these two managed pointers are &lt;em&gt;immutable&lt;&#x2F;em&gt;. When data types are immutable, it’s impossible to build anything that isn’t &lt;a href=&quot;https:&#x2F;&#x2F;ehab-hassan.github.io&#x2F;zola_test_new&#x2F;blog&#x2F;rust-cycles&#x2F;#inductive-datatypes&quot;&gt;inductive&lt;&#x2F;a&gt;: no cyclical references allowed. We need some way to inject mutability into our multiple-owner shared immutable references.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO: RefCell and RwLock&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;subtyping-and-variance&quot;&gt;Subtyping and Variance&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note 1:&lt;&#x2F;strong&gt; This section is quite involved, and only tangentially relates to &lt;code&gt;GhostCell&lt;&#x2F;code&gt;. The key takeaway is that an &lt;strong&gt;invariant lifetime can not change to another lifetime&lt;&#x2F;strong&gt; through subtyping.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note 2:&lt;&#x2F;strong&gt; This section is based on the similarly-titled section of the &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;intro.html&quot;&gt;Rustonomicon&lt;&#x2F;a&gt;. Check it out!&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Something important to think about is the relationship between type constructors (e.g. &lt;code&gt;Vec&lt;&#x2F;code&gt;) and the lifetimes of the type arguments passed to them (e.g. the &lt;code&gt;T&lt;&#x2F;code&gt; in &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;The property of this relationship is called &lt;em&gt;Variance&lt;&#x2F;em&gt;, for better or worse, and it’s important we at least understand &lt;em&gt;invariant&lt;&#x2F;em&gt; lifetimes before we continue.&lt;&#x2F;p&gt;
&lt;p&gt;This table, from the every-handy &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;subtyping.html&quot;&gt;’Nomicon&lt;&#x2F;a&gt;, shows the variance of lifetime types in Rust:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Type Constructor&lt;&#x2F;th&gt;&lt;th style=&quot;text-align: center&quot;&gt;&lt;code&gt;&#x27;a&lt;&#x2F;code&gt;&lt;&#x2F;th&gt;&lt;th style=&quot;text-align: center&quot;&gt;&lt;code&gt;T&lt;&#x2F;code&gt;&lt;&#x2F;th&gt;&lt;th style=&quot;text-align: center&quot;&gt;&lt;code&gt;U&lt;&#x2F;code&gt;&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;&amp;amp;&#x27;a T &lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;covariant&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;covariant&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;&amp;amp;&#x27;a mut T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;covariant&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;invariant&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;covariant&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;invariant&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;fn(T) -&amp;gt; U&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;contravariant&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;covariant&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;*const T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;covariant&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;*mut T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;invariant&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: center&quot;&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;There are three types of variance in Rust. Given a type constructor &lt;code&gt;F&lt;&#x2F;code&gt;, subtype &lt;code&gt;Sub&lt;&#x2F;code&gt;, and a supertype &lt;code&gt;Super&lt;&#x2F;code&gt; (so &lt;code&gt;Sub: Super&lt;&#x2F;code&gt;), variance tells us how the subtyping relationship passes through the type constructor. The variance of &lt;code&gt;F&lt;&#x2F;code&gt; is:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Covariant&lt;&#x2F;strong&gt; if subtyping passes through the type constructor. In other words, &lt;code&gt;Sub: Super&lt;&#x2F;code&gt; and &lt;code&gt;F&amp;lt;Sub&amp;gt;: F&amp;lt;Super&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Contravariant&lt;&#x2F;strong&gt; if subtyping is reversed: if &lt;code&gt;Sub: Super&lt;&#x2F;code&gt;, then &lt;code&gt;F&amp;lt;Super&amp;gt;: F&amp;lt;Sub&amp;gt;&lt;&#x2F;code&gt;. Notice the reversal!&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Invariant&lt;&#x2F;strong&gt; if subtyping is not preserved. If &lt;code&gt;Sub: Super&lt;&#x2F;code&gt;, then &lt;code&gt;F&amp;lt;Sub&amp;gt;&lt;&#x2F;code&gt; is disjoint from &lt;code&gt;F&amp;lt;Super&amp;gt;&lt;&#x2F;code&gt;. No relationship exists.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;code&gt;GhostCell&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;Token&lt;&#x2F;code&gt; uses an &lt;em&gt;invariant&lt;&#x2F;em&gt; lifetime to ensure that the lifetime remains unique. To see how lifetimes can be used in the place of others, let’s talk about &lt;em&gt;covariance&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;h3 id=&quot;covariance&quot;&gt;Covariance&lt;&#x2F;h3&gt;
&lt;p&gt;Let’s say we have a function that prints a borrowed &lt;code&gt;String&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;print_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;b&lt;&#x2F;span&gt;&lt;span&gt; String&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    println!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;,&lt;&#x2F;span&gt;&lt;span&gt; string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;&#x2F;strong&gt; Again, using &lt;code&gt;&amp;amp;String&lt;&#x2F;code&gt; rather than &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; for consistency.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;In this function, the argument we borrow from must live at least as long as &lt;code&gt;&#x27;b&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hello&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;#39;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: {
&lt;&#x2F;span&gt;&lt;span&gt;        print_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span&gt;y&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we pass &lt;code&gt;y&lt;&#x2F;code&gt; to &lt;code&gt;print_string&lt;&#x2F;code&gt;, which lives for &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;. Because &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; contains &lt;code&gt;&#x27;b&lt;&#x2F;code&gt;, it is perfectly valid to pass a &lt;code&gt;&amp;amp;&#x27;a String&lt;&#x2F;code&gt; to &lt;code&gt;print_string&amp;lt;&#x27;b&amp;gt;(...)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We know that &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; is a subtype of &lt;code&gt;&#x27;b&lt;&#x2F;code&gt;, because, as discussed in the previous section, &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; contains the lifetime &lt;code&gt;&#x27;b&lt;&#x2F;code&gt; and more. Additionally, we know that &lt;code&gt;&amp;amp;&#x27;a String&lt;&#x2F;code&gt; is a subtype of &lt;code&gt;&amp;amp;&#x27;b String&lt;&#x2F;code&gt;, because we can use &lt;code&gt;&amp;amp;&#x27;a String&lt;&#x2F;code&gt; where we expect &lt;code&gt;&amp;amp;&#x27;b String&lt;&#x2F;code&gt;. In this sense, subtyping &lt;em&gt;passes through&lt;&#x2F;em&gt; immutable borrows. Returning to the definition of covariance:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;F&lt;&#x2F;code&gt; is covariant if subtyping &lt;em&gt;passes through&lt;&#x2F;em&gt; the type constructor. In other words, &lt;code&gt;Sub: Super&lt;&#x2F;code&gt; and &lt;code&gt;F&amp;lt;Sub&amp;gt;: F&amp;lt;Super&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Looking at the example with lifetimes, &lt;code&gt;&#x27;a: &#x27;b&lt;&#x2F;code&gt; and &lt;code&gt;&amp;amp;&#x27;a T: &amp;amp;&#x27;b T&lt;&#x2F;code&gt;. Therefore, we can say that immutably borrowing a value is &lt;em&gt;covariant&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This is the most common type of variance by far:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Covariant Type&lt;&#x2F;th&gt;&lt;th&gt;Over?&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;&amp;amp;&#x27;a T &lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Covariant over both &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; and &lt;code&gt;T&lt;&#x2F;code&gt;.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Any collection type (e.g. &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;), is usually covariant over &lt;code&gt;T&lt;&#x2F;code&gt;.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;*const T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Constant pointer is covariant over &lt;code&gt;T&lt;&#x2F;code&gt;.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;So if subtyping is preserved for covariant lifetimes, what does it mean when subtyping is &lt;em&gt;not&lt;&#x2F;em&gt; preserved?&lt;&#x2F;p&gt;
&lt;h3 id=&quot;invariance&quot;&gt;Invariance&lt;&#x2F;h3&gt;
&lt;p&gt;I hope I haven’t lost you. Sometimes I get sucked into abstraction spirals; whenever I do, it’s good to relax and get concrete for a second.&lt;&#x2F;p&gt;
&lt;p&gt;Still with me? Alright.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s talk invariance! Say we have a function that mutates a &lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;mutate&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;data&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;a mut&lt;&#x2F;span&gt;&lt;span&gt; T, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;val&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; val&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now consider the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hi&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;; &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; Lives for the &amp;#39;static lifeitme
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;#39;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Bye&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y_borrow&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; y&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; Lives only for &amp;#39;a
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;mutate&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; y_borrow&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);         &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; Replaces &amp;quot;Hi&amp;quot; with &amp;quot;Bye&amp;quot; in x
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; y drops &amp;quot;Bye&amp;quot; at the end of the scope
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;    println!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;,&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; ERROR: &amp;quot;Bye&amp;quot; has been dropped!
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;At first glance, we replace &lt;code&gt;x&lt;&#x2F;code&gt;, which is &lt;code&gt;&amp;quot;Hi&amp;quot;&lt;&#x2F;code&gt; with a value borrowed from &lt;code&gt;y&lt;&#x2F;code&gt;, which is &lt;code&gt;&amp;quot;Bye&amp;quot;&lt;&#x2F;code&gt;. Then, when &lt;code&gt;y&lt;&#x2F;code&gt; exits the scope, &lt;code&gt;&amp;quot;Bye&amp;quot;&lt;&#x2F;code&gt; is dropped. When we later try to print &lt;code&gt;x&lt;&#x2F;code&gt;, aren’t we using memory after we dropped it?&lt;&#x2F;p&gt;
&lt;p&gt;Note that the above is still Aliasable XOR Mutable (AXM): we only have one mutable borrow of &lt;code&gt;x&lt;&#x2F;code&gt;, and one immutable borrow of &lt;code&gt;y&lt;&#x2F;code&gt;. Conceptually, it makes sense that this shouldn’t compile. But if AXM doesn’t explain this, what does?&lt;&#x2F;p&gt;
&lt;p&gt;Let’s write out the types passed to &lt;code&gt;mutate(data: &amp;amp;mut T, val: T)&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Arg&lt;&#x2F;th&gt;&lt;th&gt;Param&lt;&#x2F;th&gt;&lt;th&gt;Generic&lt;&#x2F;th&gt;&lt;th&gt;Arg Type&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;&amp;amp;mut x&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;data&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&amp;amp;mut &amp;amp;String&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;y_borrow&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;val&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&amp;amp;String&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;So, from the above table, &lt;code&gt;T&lt;&#x2F;code&gt; must be an &lt;code&gt;&amp;amp;String&lt;&#x2F;code&gt;. So this typechecks, right? Wrong!&lt;&#x2F;p&gt;
&lt;details&gt;
&lt;summary&gt; Expand the big ol&#x27; error message.&lt;&#x2F;summary&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0597]: `y` does not live long enough
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;main.rs:5:31
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;2  | let mut x: &amp;amp;&amp;#39;static String = &amp;quot;Hi&amp;quot;;
&lt;&#x2F;span&gt;&lt;span&gt;   |            --------------- type annotation requires that `y` is borrowed for `&amp;#39;static`
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;5  |     let y_borrow: &amp;amp;&amp;#39;a String = &amp;amp;&amp;#39;a y;
&lt;&#x2F;span&gt;&lt;span&gt;   |                                ^^^^^ borrowed value does not live long enough
&lt;&#x2F;span&gt;&lt;span&gt;6  |     mutate(&amp;amp;mut x, y_borrow);
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;8  | }
&lt;&#x2F;span&gt;&lt;span&gt;   | - `y` dropped here while still borrowed
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;You see, &lt;code&gt;x&lt;&#x2F;code&gt; and &lt;code&gt;y_borrow&lt;&#x2F;code&gt; are not the same &lt;code&gt;&amp;amp;String&lt;&#x2F;code&gt;. Remember, that the lifetime is a part of the type:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;So &lt;code&gt;x&lt;&#x2F;code&gt; is a &lt;code&gt;&amp;amp;&#x27;static String&lt;&#x2F;code&gt;, borrowed for &lt;code&gt;&amp;amp;&#x27;static&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;And &lt;code&gt;y_borrow&lt;&#x2F;code&gt; is a &lt;code&gt;&amp;amp;&#x27;a String&lt;&#x2F;code&gt;, borrowed for &lt;code&gt;&amp;amp;&#x27;a&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;But remember, &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; contains &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;, so &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; must be a subtype of &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;. If &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; is a subtype of &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;, shouldn’t &lt;code&gt;&amp;amp;mut &amp;amp;&#x27;static&lt;&#x2F;code&gt; be a subtype of &lt;code&gt;&amp;amp;mut &amp;amp;&#x27;a&lt;&#x2F;code&gt;?&lt;&#x2F;p&gt;
&lt;p&gt;Here’s the clincher:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mutable borrows (&lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt;) are invariant.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Returning to the definition of invariance:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;F&lt;&#x2F;code&gt; is invariant if subtyping is not preserved.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Even though &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; is a subtype of &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;, &lt;code&gt;&amp;amp;mut &amp;amp;&#x27;static&lt;&#x2F;code&gt; is &lt;em&gt;not&lt;&#x2F;em&gt; a subtype of &lt;code&gt;&amp;amp;mut &amp;amp;&#x27;a&lt;&#x2F;code&gt;. Subtyping &lt;em&gt;does not&lt;&#x2F;em&gt; pass through mutable borrows. For this reason, we can say that immutably borrowing a value is &lt;em&gt;invariant&lt;&#x2F;em&gt; over the lifetime involved.&lt;&#x2F;p&gt;
&lt;p&gt;So mutable and immutable borrows are two ends on opposite sides of the spectrum: immutable borrows can be covariant because even if lifetimes do not match exactly, the underlying lifetime of the value cannot be shortened because the value is immutable. This is not the case for mutable types, so mutable types must be invariant.&lt;&#x2F;p&gt;
&lt;p&gt;Any type that exhibits a pattern of this sort of &lt;em&gt;interior mutability&lt;&#x2F;em&gt; must be invariant, for the reason outlined above. Here are the core invariant types, pay special attention to the last one:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Invariant Type&lt;&#x2F;th&gt;&lt;th&gt;Over?&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;&amp;amp;&#x27;a mut T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Is invariant over &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; and covariant over &lt;code&gt;T&lt;&#x2F;code&gt;.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Interior mutability types (e.g. &lt;code&gt;RefCell&lt;&#x2F;code&gt;, &lt;code&gt;UnsafeCell&lt;&#x2F;code&gt;, atomics, etc.) are all invariant over &lt;code&gt;T&lt;&#x2F;code&gt;.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;*mut T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Mutable pointers are invariant over &lt;code&gt;T&lt;&#x2F;code&gt;.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Invariant types essentially ensure that a given lifetime can not be changed into other lifetimes. This is really important when mutating data, because we want the mutated data to live exactly as long as the data it is replacing.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;the-end-for-now&quot;&gt;The end… for now!&lt;&#x2F;h1&gt;
&lt;p&gt;Holy moly, how’s that for an exposition!? Stick around for Part II, where we put these principles into practice and derive an implementation of GhostCell from scratch!&lt;&#x2F;p&gt;
&lt;div class=&quot;boxed&quot;&gt;
&lt;p&gt;This was a longer post than usual, thanks for sticking it out to the end! Huge thanks to my incredible &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.patreon.com&#x2F;slightknack&quot;&gt;Patrons&lt;&#x2F;a&gt; for making writing this piece possible! I’m also deeply grateful to &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;mkhan45&quot;&gt;Mikail&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;realnegate&quot;&gt;Yasser&lt;&#x2F;a&gt; for reviewing (and correcting!) earlier versions of this post.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Building a Rust Mentality</title>
		<published>2022-07-21T00:00:00+00:00</published>
		<updated>2022-07-21T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/blog/shift/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/blog/shift/</id>
		<content type="html">&lt;p&gt;What really helped me begin to &lt;em&gt;grok&lt;&#x2F;em&gt; how Rust really worked was working towards building an understanding of how its &lt;em&gt;compiler&lt;&#x2F;em&gt; works.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;sensible-restrictions&quot;&gt;Sensible Restrictions&lt;&#x2F;h1&gt;
&lt;p&gt;Rust, at it’s core, is a programming language of &lt;em&gt;restrictions&lt;&#x2F;em&gt;. These restrictions exist for good reason. Upon encountering a restriction, however, it’s common to attempt to find the easiest work-around, rather than understanding the &lt;em&gt;why&lt;&#x2F;em&gt; the restriction exists in the first place.&lt;&#x2F;p&gt;
&lt;p&gt;Operating from the perspective of needless restrictions, Rust’s limitations become annoyances to memorize: don’t make that mutable here, box that async future there, make sure that trait is sized, &lt;em&gt;etc.&lt;&#x2F;em&gt;. If you take a step back, however, and look at questions surrounding the core principles of Rust—e.g. &lt;em&gt;‘what would it take to implement borrow checking?’&lt;&#x2F;em&gt; or &lt;em&gt;‘why does Rust’s async implementation require boxing so often?’&lt;&#x2F;em&gt;—you’ll soon find that a lot of these restrictions are a natural consequences of the design of the language and its compiler. I’ll give two examples of models underlying restrictions: &lt;em&gt;Aliasable xor Mutable data&lt;&#x2F;em&gt; (AxM) when borrow-checking, and &lt;em&gt;boxing Futures&lt;&#x2F;em&gt; in asynchronous contexts. I won’t be able to explain these models fully—many other guides to these princples exist elsewhere online—so here’s a brief summary:&lt;&#x2F;p&gt;
&lt;h1 id=&quot;aliasable-xor-mutable&quot;&gt;Aliasable xor Mutable&lt;&#x2F;h1&gt;
&lt;p&gt;All data in Rust is has a single &lt;em&gt;owner&lt;&#x2F;em&gt;. Temporary references to that data may be &lt;em&gt;borrowed&lt;&#x2F;em&gt; from this owner; these references must be either Aliasable xor Mutable (AxM), meaning that, at any one point in the program, there exist either &lt;em&gt;many shared references&lt;&#x2F;em&gt; to some data or &lt;em&gt;one mutable reference&lt;&#x2F;em&gt;. At the end of the day, it’s up to Rust’s borrow-checker to enforce that this is indeed the case. Since all data has only a single owner, &lt;em&gt;Rust is really good at modeling inductive datatypes&lt;&#x2F;em&gt;, i.e. objects that own all their children, e.g. trees. This is why cyclic objects—like graphs—are so hard to express in Rust: to realize a graph at the object level, you’d have to have nodes with multiple owners.&lt;&#x2F;p&gt;
&lt;p&gt;An object with multiple owners &lt;em&gt;violates the underlying principle&lt;&#x2F;em&gt; upon which Rust is able to &lt;em&gt;guarantee memory safety&lt;&#x2F;em&gt; at compile time. This is why, in the case of cyclic datastructures, &lt;em&gt;borrow-checking must be deferred to runtime&lt;&#x2F;em&gt;, either through the use of Interior Mutability (i.e. dynamically checking AxM rules), Arenas (another level of indirection, each object only has a single owner, the arena), &lt;code&gt;unsafe&lt;&#x2F;code&gt; (AxM correctness is deferred to the programmer), etc. Lifetimes and borrow-checking are hard, but by &lt;em&gt;building a mental model&lt;&#x2F;em&gt; of how the compiler works, it’ll be easier to &lt;em&gt;write code that sticks to the compiler’s strengths&lt;&#x2F;em&gt;, saving you a world of work trying to track down spurious lifetime errors.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;boxing-and-async&quot;&gt;Boxing and Async&lt;&#x2F;h1&gt;
&lt;p&gt;Rust’s &lt;em&gt;async&lt;&#x2F;em&gt; story is similar. When you &lt;code&gt;.await&lt;&#x2F;code&gt; a &lt;em&gt;future&lt;&#x2F;em&gt;, you’re essentially &lt;em&gt;taking a snapshot of all temporaries&lt;&#x2F;em&gt; (think local variables) required to finish executing the current task. Rust creates an ‘invisible struct’ to store these temporary values before yielding to the executor. As different futures may have &lt;em&gt;differently sized&lt;&#x2F;em&gt; invisible structs, a dynamic selection of futures needs &lt;em&gt;further indirection&lt;&#x2F;em&gt; (e.g. &lt;em&gt;boxing&lt;&#x2F;em&gt;) in order to have a known size at compile-time.&lt;&#x2F;p&gt;
&lt;p&gt;The unknown size of futures is also why you &lt;em&gt;can’t use recursion inside an async function without boxing&lt;&#x2F;em&gt;. Because each recursive call grows the size of the stack, and the number of recursive calls is unknown at compile-time, it is not possible to know the size of the future at compile-time. For this reason, it is required that you box the return value when recursing in an async function, such that, from the perspective of the compiler, recursive functions &lt;em&gt;return values of the same size&lt;&#x2F;em&gt;. Async&#x2F;Await isn’t actually that hard if you box everything (just look at JavaScript): Rust really wants to give low-level control to the end-user, providing general APIs that let you write custom executors that allow you to control how every single line of code in your codebase is fetched and executed. &lt;em&gt;This unyielding requirement for a leaky-but-necessary abstraction is why there appear to be so many annoying restrictions around dealing with futures in Rust.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;takeaway&quot;&gt;Takeaway&lt;&#x2F;h1&gt;
&lt;p&gt;Of course, these examples are just simplifications of the underlying model. What’s most important is &lt;em&gt;expanding your underlying model when encountering novel errors&lt;&#x2F;em&gt;. Even you get an error you’re not expecting, revise your mental model, rather than special-casing the error and tucking it away in some corner of your mind. &lt;em&gt;Developing these models takes time&lt;&#x2F;em&gt;, but Rust isn’t going anywhere: AxM is true today, and it’ll be true 10 years from now. To design things well in Rust is to embrace the restrictions, instead of fighting them. &lt;&#x2F;p&gt;
&lt;p&gt;So what does it mean to design with Rust’s strengths in mind? Like most languages in the ML family, &lt;em&gt;Rust shines when performing a series of transformations on inductively-defined datatypes&lt;&#x2F;em&gt;. For this reason, if you cognizantly design applications &lt;em&gt;holistically&lt;&#x2F;em&gt; using a functional-procedural approach, the design patterns of the language will lend themselves more naturally to the task at hand. Designing applications patterned after Rust’s strengths is probably a topic worthy of a book, or at least another blog post.&lt;&#x2F;p&gt;
&lt;p&gt;At this point I could wax poetic and pine about the pain of the inevatability leaky abstraction. On the contrary, I think Rust does an exceptional job with respect to the quality of the abstractions it provides. Although not airtight, Rust’s abstractions aim to be zero-cost. Rust pulls no punches trying to hide how things work under the hood. &lt;em&gt;If it did, it wouldn’t be Rust&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;div class=&quot;boxed&quot;&gt;
&lt;p&gt;Thanks to Erich and Joseph for reviewing earlier versions of this post.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;</content>
	</entry>
	<entry xml:lang="en">
		<title>Late Night Conversations about Nothing in Particular</title>
		<published>2022-07-15T00:00:00+00:00</published>
		<updated>2022-07-15T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/blog/late/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/blog/late/</id>
		<content type="html">&lt;h2 id=&quot;the-beginning-of-the-end-of-today&quot;&gt;The Beginning of the End (of Today)&lt;&#x2F;h2&gt;
&lt;p&gt;As I write this today, it’s tomorrow.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;and-we-re-talking-about-school&quot;&gt;And… We’re talking about school?&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;N.B. This post is not about school, bear with me.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Throughout the school year, I’m usually pretty consistent with my sleep schedule. It’s like a rhythm, every hour of my day planned out. I wake up at 5:55 exactly, do some morning studying (it’s always so much easier to get stuff done in the morning), shower an hour later, breakfast, and I’m out the door.&lt;&#x2F;p&gt;
&lt;p&gt;School’s rhythmic too. This was my last year of high school, my senior year. I think I overdid it a bit, to be honest. 6 APs and 2 college math courses, on top of, you know, everything else that goes on in life, is a bit much for anyone, &lt;em&gt;especially&lt;&#x2F;em&gt; for a simple-minded guy like me. I appreciate the rhythm school brings to my life. &lt;&#x2F;p&gt;
&lt;p&gt;So why am I writing this at 1 AM?&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;I moved schools between my Sophomore and Junior year. Before moving, I was at a much larger school (though still small by most standards, only about ~250 kids to a grade). The campus was pretty big, so it could easily take 10 minutes to walk from one class to another (classrooms were in different buildings, or ‘modules,’ scattered across campus, so it was a long outdoor walk). Because of this long walking time between classrooms, we had a long break between classes. 20 minutes of break. Like most of my friends, I hung around outside, slowly drifting from one class to another, watching a friend play Osu with a trackpad in the bright sun, or someone attempting to heroically finish the homework due next block.&lt;&#x2F;p&gt;
&lt;p&gt;Moving here, the campus was a lot smaller. We only had ~50 kids per grade, 15 classrooms in a single building made up the entire high school. Breaks were much shorter, 5 minutes, tops. But it doesn’t take that long to move from one class to another next door, and there’s not much room to congregate in the halls.&lt;&#x2F;p&gt;
&lt;p&gt;Either way, at the end of the day, during the school year, there exists a rhythm. Wake up at 5:55, do homework (just me?), go to school, attend a club, play a sport, get home, do some programming, hit the hay at 8:55, repeat. Every minute is planned and accounted for: time is allocated for work, time is allocated for play, a gentle pattern to lead your body as your mind works.&lt;&#x2F;p&gt;
&lt;p&gt;Summers, on the other hand, are very different. There is no bus leaving at 8:13 in the morning you need to catch; there’s no need to go to bed at 8:55 to get a full 9 hours of sleep. But then summer rolls around, and you find out you can get away with 6 hours of sleep, kinda, and your world becomes a mess. (Because you really can’t live on 6 in the long run; at least I can’t). School is a marathon, summer is a series of short sprints.&lt;&#x2F;p&gt;
&lt;p&gt;I don’t particularly like school, but I deeply appreciate a couple things about it. &lt;&#x2F;p&gt;
&lt;p&gt;For one, it structures my day. The rhythm of school is like steady onslaught of ocean waves. Understanding this rhythm helps me plan ahead, figuring out how to fortify my day to avoid burnout after each wave hits.&lt;&#x2F;p&gt;
&lt;p&gt;For two, it’s where social stuff happens. For those of you who know me, you know that I move often. (For those of you who don’t, welcome to the blog!) In general, I think the friends you make is highly dependent on the people you’re around, and there’s nobody your around more often than the peeps at school.&lt;&#x2F;p&gt;
&lt;p&gt;I’ve been lucky enough to have done well in school (so far, we’ll see what MIT makes of me. A mess, I suppose). I take tests well; I do my homework at school so I don’t have to do it at home; and I generally get along well with people.&lt;&#x2F;p&gt;
&lt;p&gt;As I’ve now graduated, however, I’ve realized that this structure I have come to rely on in high school will no longer exist, at least not to the same degree. With graduation comes an eternal summer, school optional. Enough with school!&lt;&#x2F;p&gt;
&lt;p&gt;So as I write this today, it’s tomorrow.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wait-if-it-s-today-how-s-it-tomorrow&quot;&gt;Wait, if it’s today, how’s it tomorrow?&lt;&#x2F;h2&gt;
&lt;p&gt;It’s currently past midnight, yet I’m still awake, therefore it’s still yesterday. I don’t think my day counter increments until I’ve woken up. It’s funny how that works. Before time was standardized, you went to bed when it was dark, and woke up when it was light. Nowadays you can &lt;em&gt;relax&lt;&#x2F;em&gt; in the dark. Join me: turn down your screen real low, and type the night away.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-meta-break&quot;&gt;A Meta Break&lt;&#x2F;h2&gt;
&lt;p&gt;When I started writing this post, I wasn’t quite sure what it was going to be about. I’m still not. As you can tell, dear reader, I’ve adopted the role of a meta commentator. You should be able to tell we’re approaching a topic transition. Something new’s coming up, a little different, but I’ll all tie it together in the end. Or so you hope; maybe you’ve stopped reading. I, personally, have no idea what the next topic’s going to be.&lt;&#x2F;p&gt;
&lt;p&gt;Speaking of, I originally started this post to paste in two things I wrote earlier today. Someone commented that since I “seem good at sciency writing” and “good with words” I “should write a book (or at least a blog) some time.” &lt;&#x2F;p&gt;
&lt;p&gt;The problem is, I &lt;em&gt;do&lt;&#x2F;em&gt; have a blog (hiya, you’re reading it), but I fill it with whatever I think up of at 1:04 AM. (When else do you blog?) 90% of the posts on this blog are messages I’ve written elsewhere, e.g. via email or discord, and then have wanted to repost elsewhere without literally having N different copies of X floating around. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-mess-i-m-in&quot;&gt;The Mess [I’m] In&lt;&#x2F;h2&gt;
&lt;p&gt;That reminds me. I swear I’ve mentioned this talk before, but I keep coming back for it. It’s called “The Mess We’re In” and it’s by Joe Armstrong of Erlang fame. Y’know what? I really wished I had had the chance to meet Joe Armstrong. He reminds my of my grandpa: concise with his words, able to break down any idea, no matter how complex, into a simple string of words a twelve year old could not just acknowledge, but deeply understand. It’s a true talent, and it’s one I hope to develop myself. &lt;&#x2F;p&gt;
&lt;p&gt;Perhaps that’s why I’m staying up late writing. Practice is essential.&lt;&#x2F;p&gt;
&lt;p&gt;But I digress. I love this talk because, in all honestly, we’re all screwed. And not just in a metaphorical sense. Software, in general, is a mess. A big one. Javascript on the Web is Duct-Tape and [object Superglue]. I try to avoid it with a 10-foot pole, made mostly of Wasm and CSS, but sometimes that isn’t even enough.&lt;&#x2F;p&gt;
&lt;p&gt;Joe mentions that the reason for this mess is needless duplication. For example, in our day to day work as programmers, we probably author about 3 new files a day, on average. By the time you’re old and wise like Armstrong, that’s thousands of files! If we’re going with raw numbers:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;3 files a day, 365 1&#x2F;4 days a year, 50 years programming is 54 thousand files!&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;54k files is insane! It’s a lifetime of work! Given how easy it is to repeat ourselves online, it’s dubious that every single one of those files is unique. There’s bound to be, within that collection, files that you’ve copied and modified, files that you’ve written once, forgotten about, and reimplemented from scratch. Files that do the same thing in different orders, or different things in the same order.&lt;&#x2F;p&gt;
&lt;p&gt;So if you were to take this massive corpus accumulated over the course of a lifetime, and add a single new file, how much new, unique information would it actually contain? I posit very little, through no fault of anyone.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;least-compression-difference&quot;&gt;Least Compression Difference&lt;&#x2F;h2&gt;
&lt;p&gt;Armstrong proposes the idea of least compression difference. Now this is particularly clever. Let’s say you have two files, A and B, and you want to know how similar A is to B. &lt;&#x2F;p&gt;
&lt;p&gt;First, you compress A, and then you compress B—you take the sizes of these two compressed files and add them together—that’s your baseline.&lt;&#x2F;p&gt;
&lt;p&gt;Then, you concatenate A and B, and compress them both together. Because A and B are compressed at the same time, a really good compressor should be able to factor out information in B that already exists in A. If A and B were identical, then the final size of the pair would be very small indeed: just duplicate the contents of the first compressed file, and so on.&lt;&#x2F;p&gt;
&lt;p&gt;So the distance is a scalar value between zero and one, calculated by taking the size of both files compressed together over the sum of the sizes of both files separately. To whip out the reliable ol’ pseudocode, something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;least_compression_distance&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;A, B&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    separate &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;size&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;compress&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;A&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)) + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;size&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;compress&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;B&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    together &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;size&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;compress&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;A &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;++&lt;&#x2F;span&gt;&lt;span&gt; B&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; together &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span&gt; separate
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The problem is that this is pretty expensive to calculate. Lossless compression can’t magically make everything smaller: for every string that compresses to something smaller, theres another string that compresses to exactly that much larger.&lt;&#x2F;p&gt;
&lt;p&gt;Lossless compression assigns shorter strings to more structured patterns. In a sense, compression aims to make the length of whatever string you’re compressing equal to the amount of information it contians.&lt;&#x2F;p&gt;
&lt;p&gt;You can turn any lossy compressor into a lossless one by compressing, decompressing, and recording the differences. In essence, each level of lossy compression leaves some noise behind that is slightly harder to compress.&lt;&#x2F;p&gt;
&lt;p&gt;And nonetheless, yet again, I digress.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;compression-and-intelligence&quot;&gt;Compression and Intelligence&lt;&#x2F;h2&gt;
&lt;p&gt;It’s a well-known fact that compression is equivalent to general intelligence. (I say it’s a well-known fact because it’s 1:28 AM and I’m too tired to go around digging for a link, but maybe future me will grab one for ya after this goes live.) Better compressors are smarter. As the residual noise becomes harder and harder to compress, smarter compressors will find the hidden structure in the noise, pull it out, and keep moving forward.&lt;&#x2F;p&gt;
&lt;p&gt;So Armstrong’s least compression is very interesting, because it does indeed tell you how much new information is actually introduced in B. If A is the entire corpus of what you’ve written, and B is a new file, taking &lt;code&gt;compress(A + B) - compress(A)&lt;&#x2F;code&gt; will tell you &lt;em&gt;exactly&lt;&#x2F;em&gt; how much new information B contains. And as compressors get better, so will the accuracy of the above expression.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fixing-the-mess-we-re-in&quot;&gt;Fixing the Mess We’re In&lt;&#x2F;h2&gt;
&lt;p&gt;So I’ve long had a dream, like Armstrong, of this magical program that follows you around. It tracks everything you do. Everything you type, everything you read, everything you watch, everything you listen to. (Locally, of course, we wouldn’t want this to get dystopian quite yet; after all, it is a mess that we’re trying to clean up.)&lt;&#x2F;p&gt;
&lt;p&gt;This program takes everything you’re taking in and writing out, and looks for patterns. It takes the unorganized, repetitive firehose of information, compares it against information it’s neatly packaged away, fills a cup with the new information introduced, and neatly packages it away for future reference.&lt;&#x2F;p&gt;
&lt;p&gt;Over time, you accumulate a massive library. But this is not a messy library. Those 54 thousand files you wrote? Oh, there there, but you realize that only 3 thousand of them contain new information, right? You’d like me to rewrite those 54 thousand to the equivalent 3, pulling in what other stuff you’ve read to make them as human-readable and understandable as possible? It’s a lot to ask, but here you go. I recommend you start with the simple computational axioms, and build up from there; a monad is simply a monoid in the category of enfunctors, and it takes more than one universe to show that.&lt;&#x2F;p&gt;
&lt;p&gt;I think this is what I want my life’s work to be. Armstrong jokes that ‘if you want a problem that will keep you busy for the next 40 years, here’s one,’ but I’m serious. I don’t want 40 years, I want to work on this for the rest of my life.&lt;&#x2F;p&gt;
&lt;p&gt;I think we’re in a huge mess. For real. And I apologize, some of it is my fault; just look at this website. Zstd says that this file, while being 24 kilobytes large, only contains 3 kilobytes of unique (uncompressable) information.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;out-of-the-blue&quot;&gt;Out of the Blue&lt;&#x2F;h2&gt;
&lt;p&gt;All this talk of compression has got me thinking, so now is the time I’ll paste in the actual discussion I wrote this blog post to discuss:&lt;&#x2F;p&gt;
&lt;div class=&quot;boxed&quot;&gt;
&lt;h2 id=&quot;human-values-are-universal-because-we-all-share-similar-experiences&quot;&gt;Human values are universal, because we all share similar experiences&lt;&#x2F;h2&gt;
&lt;p&gt;I don’t think it’s possible to comprehend how much our imparted values affect our worldview. I think human culture across the globe is fairly homogenous in this sense.&lt;&#x2F;p&gt;
&lt;p&gt;For example, let’s say you learn how to ride a bike, or drive a car, or type on a keyboard, or read. It’s really hard at first, because you have to think about what every little motor action will end up doing, even if it doesn’t map to past experience. But after like a few months of consistent practice, these conscious thoughts get chained together and pushed down to lower levels of abstraction in the brain (in the Hawkinsian sense), to the point where you are no longer ‘pushing on pedals’ and ‘steering to stay balanced,’ but ‘biking to a friend’s house.’ The input -&amp;gt; output map is completely different than what would physically happen if the tool were not there, but your body quickly adapts to the nonlinearities and treats the tool as if it were merely an extension of your body. This is all well-known.&lt;&#x2F;p&gt;
&lt;p&gt;Now here’s what I posit: What if you grew up where you didn’t just learn how to ride a bike, but were always riding a bike? If that convoluted analogy didn’t make much sense, here’s an analogy: the neocortex is fairly uniform and unspecialized at birth, essentially hijacking the lower brain, like a parasite animating a corpse (ok, that could’ve been worded better). Needless to say, your body doesn’t start with preconceived mappings (or if they are, they’re fairly plastic, if riding a bike is any indication). If you took a slice of neocortex—some head cheese, if you will—and mapped I&#x2F;O to something completely arbitrary, say a 2D simulation or game, or a car with cameras and motors, I believe that (despite being very inhumane) the brain would eventually learn correct I&#x2F;O pairs, and be able to act in its limited environment. &lt;&#x2F;p&gt;
&lt;p&gt;Because their experience is so different than our own, their worldviews, and hence their values, will be alien and incomprehensible compared to our own, wouldn’t you agree?&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;And more importantly:&lt;&#x2F;p&gt;
&lt;div class=&quot;boxed&quot;&gt;
&lt;h2 id=&quot;welcome-to-earth-the-cosiest-corner-of-the-universe-fractal&quot;&gt;Welcome to Earth, the Cosiest Corner of the Universe Fractal&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Here’s a video for ya: &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=4c1lqFXHvqI&quot;&gt;Can we create new senses for humans?&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;I just started this talk, and I’m already enjoying it. The other day I was thinking about how the universe is fractal-like in complexity and activity at every scale. Just compare sprawling human cityscapes to sprawling proteins in the cell, millions of little machines doing their best to deal with the hurricane of movement all around. Zoom out to the galactic level, and watch the dance of planets: complex emergent behavior driven by an infinite number of gravitational interactions at every point in space. At every scale, there exists this underlying idea of ‘computational irreducibility’—behaviors that are too complex to model too far into the future. We exist at a single scale, 10^0 meters, and in a single location: 1g, 1atm, 1au. Just imagine the amount of possible stimuli that exist. Our values are shaped by the world we inhabit, and yet there are a near-infinite of worlds—as complex as our own—right where you are now, just at different scales, both spatially and temporally. It’s incredible, really. &lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;The universe is fractal-like in complexity and activity at every scale. Compressing the universe, locally reversing entropy (and using this word wrong in two ways), requires &lt;em&gt;understanding&lt;&#x2F;em&gt; the structure universe at a deep level, beyond anything what we’re capable of.&lt;&#x2F;p&gt;
&lt;p&gt;And I think this idea: creating things beyond what I alone am capable of, is what I find to be the most appealing. I want to simulate the universe, baby!&lt;&#x2F;p&gt;
&lt;p&gt;So this reminds me of two related topics, which I’ll sketch out here.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-universe-approximated&quot;&gt;The Universe, Approximated&lt;&#x2F;h2&gt;
&lt;p&gt;First is the idea of Spatiotemporal Accelaration Structures, or modeling the universe with Neural Cellular Automata. The idea is pretty simple:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We start with a base rule. This could be something simple like Conway’s Game of Life, something more complex, like Reaction Diffusion, or something impossible, like encoding the laws of quantum mechanics in cells a planck-length wide, stepping time one planck after another. Let’s say that the stepping the base rule requires only the 8 surrounding neighbor cells (or say 26 in 3D).&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Next, we group each group of four cells into groups of 2x2, a macrocell (hashlife flashbacks). This is like laying another grid over the one we have now, but twice as big. We look at each macrocell, and its 8 surrounding neighbors. Taking a neural network, we take all 2x2x3x3 = 36 surrounding base cells, convert them into a vector of length 36, and pass them through a neural network to create a new vector representing the base cell. We train two networks: one that can turn base cells into macrocells, and one that can turn macrocells into base cells.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Then, on the base layer, we step the simulation not once, but twice, and compute a new vector for each macrocell. We train a third neural network on predicting the new vector for each macrocell given the old one. This can be trained end-to-end with the other two neural networks, minimizing the predictive error between the initial state at the base layer and the predicted state at the base layer, flowing through macrocells in the middle.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;This step is the trickiest one. We recurse. Take each macrocell, and treat it as a base cell. Your rule at this level is not hardcoded, but determined by the neural network trained on predicting the underlying layer at double speed. Create a new macrocell layer—this one’s 4x4—and train 3 more neural networks on raising, lowering, and taking steps 4 at a time. If you’re feeling really fancy, you can re-use the original three networks, and hope that it generalizes rules across scales, encoding scale-based information in the vector representation of each macrocell. Repeat &lt;em&gt;ad infinitum&lt;&#x2F;em&gt;: 4x4 -&amp;gt; 8x8 -&amp;gt; … -&amp;gt; length x height of universe.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;And now this is where things get fast. Instead of storing the base grid, store a lazily populated quadtree. Run the simulation 1 step at a time, training the network as you go along. When a macrocell predicts its base cells at, say, 99% accuracy, trim the base cells. When accuraly drops below a certain threshold, regenerate the base cells and step a layer of abstraction lower. Parts of the simulation that are more complex to model will require more cells.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;And that’s it. That’s how you build a universe simulator.&lt;&#x2F;p&gt;
&lt;p&gt;Hubris aside, this is an idea I’ve been playing around with in my head for a while. I started implementing it, got some promising smooth life speedups (after all, SAT is sort of a generalized continuous hashlife), but that’s when I ran out of steam.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-universe-content-addressed&quot;&gt;The Universe, Content Addressed&lt;&#x2F;h2&gt;
&lt;p&gt;The next idea I’ve had for a while is much more similar to Armstrong’s Sherlock, e.g. universal information compresser and mess cleaner upper, and it has to do with content-addressed storage.&lt;&#x2F;p&gt;
&lt;p&gt;For the unfamiliar, content-addressed storage is quite interesting. Essentially, we take a blob of information, and hash it, take its fingerprint. If we give the store the fingerprint, it’ll give us back our blob. Easy as pie.&lt;&#x2F;p&gt;
&lt;p&gt;But the interesting question is not how to make the store, but how to make one that’s space-effective. If two blobs are very similar (say by the measure of, I don’t know, least compression distance, wink wink), we’d ideally want one blob to be encoded in terms of the other, deduplicating information. But to do this, we’d need some way to quickly compare similar blobs. We can’t use full least-compression distance—that’s very expensive—but we can use these bloom filter things I came up with that don’t have a name.&lt;&#x2F;p&gt;
&lt;p&gt;But first, hash splitting. A pure content-addressed store doesn’t care about blob size. Got a 2TB blob lying around? Chuck it in, we’ll handle it! But large blobs are problematic for a number of reasons. What if you change a single character in that 2TB blob. Are you going to store the whole thing again? Well, ideally no, and that’s where hash splitting comes in.&lt;&#x2F;p&gt;
&lt;p&gt;The idea is deceptively simple: slide a window 32 characters in length across the entire big blob we want to store. Hash each window. When we hit a hash with a certain number of leading high bits set, split the blob at that point. For example, if you made it so that 1 in every 1024 hashes causes a split, then you’d end up with blobs close to 1024 bytes (i.e. 1KiB) in length (or something, these sorts of distributions are weird).&lt;&#x2F;p&gt;
&lt;p&gt;Storing a lot of 1KiB blobs is a lot easier than storing a few 2TB blobs, especially because they’re content addressed. If you make a 1 character change to that 2TB file, the splitting algorithm should preserve all other blocks; in other words, only 1KiB block out of the 2TB file will need to be added.&lt;&#x2F;p&gt;
&lt;p&gt;But we only changed 1 character! Why do we need to add 1KB worth of new information!?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-universe-compressed&quot;&gt;The Universe, Compressed&lt;&#x2F;h2&gt;
&lt;p&gt;And this is where the second cool idea comes in. Bloom filter things! Divide your rolling window hash into an even number of buckets, say 512. Each hash lands in one of these buckets. When processing a small 1KiB block, create a 512 bit array. As you go over the block, take the bucket of the hash of each window, and set the corresponding bit in the bit array to high. If two blocks are identical, they’ll have the same bloom representation. If only one character is changed, they’ll both have similar bloom representations. We can quantify the distance between two blocks in a pretty simple way: just &lt;code&gt;XOR&lt;&#x2F;code&gt; the bloom filters and take a &lt;code&gt;popcnt&lt;&#x2F;code&gt;. In other words, count the number of bits that are different between the two.&lt;&#x2F;p&gt;
&lt;p&gt;This isn’t as accurate as least compression distance, but from my tests, it does a pretty dang good job. &lt;&#x2F;p&gt;
&lt;p&gt;When inserting a new block, we could compare against every existing bloom filter, but that would be slow. Instead, here’s another idea: What if we treated each bit array as a discrete vector of sorts, and used something like FAISS to built an efficient index of all the vectors? Then, finding the most similar block to the one we have would be a simple index lookup, which is way cheaper that comparing our new block’s bloom against every other bloom in existence.&lt;&#x2F;p&gt;
&lt;p&gt;So when we insert a new block, we grab, say, the top K closest blocks. We then run something like least compression distance or a myers diff to find the most similar blocks (this is cheap, because blocks are around 1KiB in size; it’s not like we’re diffing 2TB files). Instead of storing the new block, we store a compressed representation of it, and the address of the most similar other block. This way, a one-character change to a 2TB file becomes a 1 block change, but we found the closest block and know it’s just a 1 character insertion, so we encode that insertion in 4 bytes, plus a few more for the address of the block we’re appending to, for a grand total of, say, 36 bytes. &lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;This sentence is only 36 bytes long.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For effect, the above sentence is as long as how much additional information we need to store. For changing a single character in a 2TB file. Recording this change so effectively is like finding a needle in a haystack. This is why I love content-addressed storage.&lt;&#x2F;p&gt;
&lt;p&gt;So if I were to flesh out my prototype of a mess-cleaner-upper, I think it would look something like this. Hash-splitting to divvy up information, content-addressing for identifying it, locality-sensitive hashing for finding similar blocks, and least compression and diffing for storing changes effectively. This is what we’re missing.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;and-recurse&quot;&gt;And… Recurse&lt;&#x2F;h2&gt;
&lt;p&gt;As I write this today, it’s tomorrow.&lt;&#x2F;p&gt;
&lt;p&gt;It’s 2:36 AM. I’m getting really tired. But I think it was worth it.&lt;&#x2F;p&gt;
&lt;p&gt;These are ideas that have been simmering in my mind for a while, no doubt. I’m glad that I got it all out today. This is what summer is for, in all its chaos. During the school year, goin through the motions of class, it’s hard to sit down for a couple of hours to entertain ideas like these. To see where the mind leads. Yet here we are.&lt;&#x2F;p&gt;
&lt;p&gt;I think balance and moderation in all things is one of the most important principles of all, when used in moderation. &lt;&#x2F;p&gt;
&lt;p&gt;So before I hit the hay, a few final words:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Don’t be afraid to suspend disbelief and follow where new ideas take you; you never know where you might end up.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;editor-s-note&quot;&gt;Editor’s Note&lt;&#x2F;h2&gt;
&lt;p&gt;This post is a mess. Sometime in the future, maybe I’ll swing by add some headings, pictures, videos; clean up my prose, make it feel nice. If you made it this far, you probably just jumped to the bottom—but if you scrolled and read it… than there’s nothing more that I can say than Thank You, I hope you enjoyed the ride. &lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Traits as implicit conversion</title>
		<published>2022-02-28T00:00:00+00:00</published>
		<updated>2022-02-28T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/passerine/traits-as/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/passerine/traits-as/</id>
		<content type="html">&lt;p&gt;The joy of writing a &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;passerine.io&quot;&gt;new programming language&lt;&#x2F;a&gt; is coming up with novel ideas and seeing if they stick. &lt;&#x2F;p&gt;
&lt;p&gt;The challenge I’m attempting to solve stems from dealing with different types of objects that share common structure or behavior. For this reason I’ve been thinking a lot about how to rectify open&#x2F;closed enumerations, traits, and type constructors.&lt;&#x2F;p&gt;
&lt;p&gt;Traditional object-oriented languages deal with this through the use of inheritance. For example since both a &lt;code&gt;Wizard&lt;&#x2F;code&gt; and a &lt;code&gt;Person&lt;&#x2F;code&gt; have a &lt;code&gt;name&lt;&#x2F;code&gt;, they may both inherit from a single &lt;code&gt;Named&lt;&#x2F;code&gt; class. In Java, we may write this as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Named &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Person &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;extends &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Named &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span&gt;age&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Wizard &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;extends &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Named &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span&gt;title&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span&gt;skill&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is all well and dandy, but problems quickly arise. Java only supports single inheritance, so if we want a new class to extend both &lt;code&gt;Named&lt;&#x2F;code&gt; and, say &lt;code&gt;Aged&lt;&#x2F;code&gt;, we’d either have to create a new class (like &lt;code&gt;NamedAndAged&lt;&#x2F;code&gt;, gross), or use a language with &lt;em&gt;multiple inheritance&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Multiple inheritance sucks for other reasons, though, mostly due to the &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Multiple_inheritance#The_diamond_problem&quot;&gt;diamond dependency problem&lt;&#x2F;a&gt;. If we even create a class that inherits from two superclasses with the same field, which field gets used? Does the object have two fields?&lt;&#x2F;p&gt;
&lt;p&gt;This is a problem as old as the hills, and it’s why we’ve developed sayings—like ‘always choose composition over inheritance’—that have been passed down from developer to developer, generation after generation.&lt;&#x2F;p&gt;
&lt;p&gt;We don’t have to be stuck with the pains inheritance, though! Inheritance is really just ensuring that different objects share certain structure and&#x2F;or behavior. Ultimately this is what composition over inheritance means: Instead of having a &lt;code&gt;Person&lt;&#x2F;code&gt; that is &lt;code&gt;Named&lt;&#x2F;code&gt;, just make a &lt;code&gt;Person&lt;&#x2F;code&gt; have a &lt;code&gt;Name&lt;&#x2F;code&gt;, and pass that &lt;code&gt;Name&lt;&#x2F;code&gt; around when required:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Name &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Person &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span&gt;age&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Name &lt;&#x2F;span&gt;&lt;span&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;While nice, this required that person carry around a &lt;code&gt;name&lt;&#x2F;code&gt; field; if the name can be derived from existing class data, this may be redundant. We could use a method, of course:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Person &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Name &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;() { 
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; ... 
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But the problem here is that there’s no real &lt;em&gt;consistency&lt;&#x2F;em&gt; between the various ways of representing that a &lt;code&gt;Person&lt;&#x2F;code&gt; has a name. Do we access a field, call a method, etc?&lt;&#x2F;p&gt;
&lt;p&gt;But you know the solution to this! Just use typeclasses&#x2F;traits&#x2F;interfaces, you shout! Instead of adding methods and fields ad-hoc, we declare a shared &lt;code&gt;trait&lt;&#x2F;code&gt; (to use the Rust parlance) with common behavior:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span&gt;Named &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;) -&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; String&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then, if we have a person, we can implement &lt;code&gt;Named&lt;&#x2F;code&gt; for &lt;code&gt;Person&lt;&#x2F;code&gt; to show that a person indeed has a name:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Person &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; String,
&lt;&#x2F;span&gt;&lt;span&gt;    age&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:  &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Named &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Person &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ff5370;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;) -&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; String &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ff5370;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can access this field using regular method call syntax, like &lt;code&gt;person.name()&lt;&#x2F;code&gt;. If we implement another trait that &lt;em&gt;also&lt;&#x2F;em&gt; has a name method, then we must use Rust’s Uniform Function Call Syntax (UFCS) to disambiguate: &lt;code&gt;Named::name(&amp;amp;person)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Whatever you call it, the core idea behind traits&#x2F;typeclasses&#x2F;interfaces&#x2F;etc. is simple: define a single interface with a number of behaviors through which the underlying object is accessed.&lt;&#x2F;p&gt;
&lt;p&gt;My largest issue with these systems is that &lt;em&gt;another layer&lt;&#x2F;em&gt; on top of the language itself. This description may not be entirely clear, so let’s jump into some examples in Passerine:&lt;&#x2F;p&gt;
&lt;h1 id=&quot;a-modest-proposal&quot;&gt;A modest proposal&lt;&#x2F;h1&gt;
&lt;p&gt;Say we have a struct; it’s for a &lt;code&gt;Person&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;type Person = {
&lt;&#x2F;span&gt;&lt;span&gt;    name: String,
&lt;&#x2F;span&gt;&lt;span&gt;    age:  Nat,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we wanted to make a new &lt;code&gt;Person&lt;&#x2F;code&gt;, we’d just construct it:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    name: &amp;quot;Gerald&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    age:  69,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can write functions that update &lt;code&gt;Person&lt;&#x2F;code&gt;, too:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;birthday = Person { name, age          } 
&lt;&#x2F;span&gt;&lt;span&gt;        -&amp;gt; Person { name, age: age + 1 }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So far, this is all pretty standard. When you think about it, constructing a &lt;code&gt;Person&lt;&#x2F;code&gt; is just wrapping a bare struct in the &lt;code&gt;Person&lt;&#x2F;code&gt; newtype. In fact, this is completely valid:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;inner = { name: &amp;quot;Bob&amp;quot;, age: 27 }
&lt;&#x2F;span&gt;&lt;span&gt;bob = Person inner
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In essence, &lt;code&gt;Person&lt;&#x2F;code&gt; is a constructor: a function that takes some data and produces some data of that type:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;Person : { name: String, age: Nat } -&amp;gt; Person
&lt;&#x2F;span&gt;&lt;span&gt;       = { name,         age      } -&amp;gt; Person { name, age }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In fact, for any type we define, we essentially get the following constructor for free:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;Type : Inner -&amp;gt; Type
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By default, &lt;code&gt;Inner&lt;&#x2F;code&gt; is a single type: it’s literally the inner contents of &lt;code&gt;Type&lt;&#x2F;code&gt;. &lt;&#x2F;p&gt;
&lt;h1 id=&quot;dynamic-dispatch&quot;&gt;Dynamic dispatch&lt;&#x2F;h1&gt;
&lt;p&gt;This brings me to traits. A trait is essentially a set of different objects that share the same behavior. In Rust, for example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span&gt;Animal &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;feed&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;()  -&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; String&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;speak&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;() -&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; String&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Anything that you can &lt;code&gt;feed&lt;&#x2F;code&gt; or &lt;code&gt;say&lt;&#x2F;code&gt; can be defined to be an &lt;code&gt;Animal&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Cat
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; A cat is an Animal
&lt;&#x2F;span&gt;&lt;span&gt;impl Animal for Cat &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    fn feed()  { &amp;quot;not hungry&amp;quot;.to_string() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;speak&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;() {      &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;meow!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;() }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Traits are useful for modeling systems that expect different objects with defined shared behavior. For example, we can define a trait that represents &lt;code&gt;Iterator&lt;&#x2F;code&gt; over an arbitrary stream:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; Abridged from Rust&amp;#39;s standard library
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span&gt;Iterator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;Item&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Option&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#89ddff;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt;Item&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Anything has a notion of being advanced via &lt;code&gt;next&lt;&#x2F;code&gt;, whether that be moving a cursor through an array or traversing nodes in a tree, can be used as an &lt;code&gt;Iterator&lt;&#x2F;code&gt;. For example, here’s how we might iterate through a &lt;code&gt;Vec&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;VecIter&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    index&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; Ignoring some lifetime stuff for the sake of simplicity
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; Iterator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;VecIter&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;Item &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Option&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ff5370;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;index &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;+= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ff5370;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ff5370;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;index &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;vec_to_iter&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;) -&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; VecIter &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    VecIter &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{&lt;&#x2F;span&gt;&lt;span&gt; index&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; vec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That’s simple enough. calling &lt;code&gt;vec_to_iter(vec![1, 2, 3])&lt;&#x2F;code&gt; will produce a &lt;code&gt;VecIter&lt;&#x2F;code&gt; which can be used as an &lt;code&gt;impl Iterator&amp;lt;Item=usize&amp;gt;&lt;&#x2F;code&gt;, an iterator over the numbers 1, 2, and 3.&lt;&#x2F;p&gt;
&lt;p&gt;But if you were to represent an iterator as an &lt;em&gt;actual type&lt;&#x2F;em&gt;, how would you go about doing that?&lt;&#x2F;p&gt;
&lt;p&gt;Well, we know that an iterator produces &lt;code&gt;Item&lt;&#x2F;code&gt;s of a certain type, and has a single function that advances state:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Iterator&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Item&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Box&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;dyn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;FnMut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Option&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Item&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And then why don’t we just have &lt;code&gt;vec_to_iter&lt;&#x2F;code&gt; return, well, an &lt;code&gt;Iterator&lt;&#x2F;code&gt;?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; Again, completely ignoring the borrow checker lol
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;vec_to_iter&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;) -&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; Iterator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; index &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; vec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Iterator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Box&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt;new&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(|| {
&lt;&#x2F;span&gt;&lt;span&gt;            index &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;+= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ff5370;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;index &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;})
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see, an iterator is just a concrete type containing a higher-order function. In this non-trait version, implementing &lt;code&gt;Iterator&lt;&#x2F;code&gt; is as simple as &lt;em&gt;constructing&lt;&#x2F;em&gt; Iterator.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; iter &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;vec_to_iter&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;vec!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;])
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)(); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; Some(1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)(); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; Some(2)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)(); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; Some(3)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)(); &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; None
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Rust makes this a bit harder because none of the code we just wrote would actually compile, but this should illustrate the point.&lt;&#x2F;p&gt;
&lt;p&gt;But the point is: traits can be represented as plain old types. &lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Aside:&lt;&#x2F;strong&gt; Agda and inference&lt;&#x2F;p&gt;
&lt;p&gt;TODO: Write about how Agda builds off this, it’s really cool!&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Anyway, let’s hop back to Passerine.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;wizards-are-people-too&quot;&gt;Wizards are people too.&lt;&#x2F;h1&gt;
&lt;p&gt;Starting with our definition for &lt;code&gt;Person&lt;&#x2F;code&gt; from earlier, let’s also define a &lt;code&gt;Wizard&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;type Person = {
&lt;&#x2F;span&gt;&lt;span&gt;    name: String,
&lt;&#x2F;span&gt;&lt;span&gt;    age:  Nat,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;type Wizard = {
&lt;&#x2F;span&gt;&lt;span&gt;    title: String,
&lt;&#x2F;span&gt;&lt;span&gt;    name: String,
&lt;&#x2F;span&gt;&lt;span&gt;    skill:  Nat,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now wizards are people too. All wizards are actually as physically fit as a 25 year old (how else do you think they are so darn fast?), but their outward age-defined appearance is a pure function of &lt;code&gt;skill&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;So let’s say we have a function that takes a &lt;code&gt;Person&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;call_for_dinner = Person { name, .. } -&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    println &amp;quot;Hey {name}, it&amp;#39;s time for dinner! Come and eat!&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now wizards are people too: wouldn’t it be nice if we could call our wizard friends over for dinner as well?&lt;&#x2F;p&gt;
&lt;p&gt;We could write a conversion function that temporarily converts a &lt;code&gt;Wizard&lt;&#x2F;code&gt; into a &lt;code&gt;Person&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;wizard_to_person = Wizard { title, name, skill } 
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; Person {
&lt;&#x2F;span&gt;&lt;span&gt;        name: &amp;quot;{name} the {title}&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        age:  25 + skill &#x2F; 10,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So if we have a &lt;code&gt;Wizard&lt;&#x2F;code&gt;, say &lt;code&gt;merlin&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;merlin = Wizard {
&lt;&#x2F;span&gt;&lt;span&gt;    title: &amp;quot;Wise&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    name:  &amp;quot;Merlin&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    skill: 930,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can call &lt;code&gt;merlin&lt;&#x2F;code&gt; over to dinner:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;call_to_dinner (wizard_to_person merlin)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Hey Merlin the Wise, it’s time for dinner! Come and eat!&lt;&#x2F;p&gt;
&lt;p&gt;The only thing missing for this to be a trait system would be some way to convert &lt;code&gt;merlin&lt;&#x2F;code&gt; to a &lt;code&gt;Person&lt;&#x2F;code&gt; automatically…&lt;&#x2F;p&gt;
&lt;h1 id=&quot;from-a-to-b&quot;&gt;from A to B&lt;&#x2F;h1&gt;
&lt;p&gt;So, back to constructors. &lt;&#x2F;p&gt;
&lt;p&gt;Remember that when we’re constructing a &lt;code&gt;Person&lt;&#x2F;code&gt;, &lt;code&gt;Person&lt;&#x2F;code&gt; essentially serves as a function with the following type:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;Person : { name: String, age: Nat } -&amp;gt; Person
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In other words, we take a record (i.e. struct) representing a person, and produce a semi-opaque object of type &lt;code&gt;Person&lt;&#x2F;code&gt;. Reasonable enough.&lt;&#x2F;p&gt;
&lt;p&gt;But what if we could make &lt;code&gt;Person&lt;&#x2F;code&gt; construct over additional types?&lt;&#x2F;p&gt;
&lt;p&gt;The most obvious extension would be some sort of row polymorphism (as Passerine aims to eventually be row-polymorphic, in the tradition of ML-style languages). If we provide a record with additional fields to &lt;code&gt;Person&lt;&#x2F;code&gt;, person should ignore those fields:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;Person { 
&lt;&#x2F;span&gt;&lt;span&gt;    name: &amp;quot;Joe&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;    age: &amp;quot;5&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;    birthday: &amp;quot;2022-05-23&amp;quot; 
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this case, the &lt;code&gt;birthday&lt;&#x2F;code&gt; field would be ignored. If we were to write this as a type, we could say that:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;Person : { name: Nat, age: String } 
&lt;&#x2F;span&gt;&lt;span&gt;       | { name: Nat, age: String, .. } -&amp;gt; Person
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Remember that &lt;code&gt;|&lt;&#x2F;code&gt; is a sum type (i.e. enum). This is a bit redundant, as the former type is a subtype of the latter.&lt;&#x2F;p&gt;
&lt;p&gt;Taking some more creative liberties, let’s say that we want a person constructed with no &lt;code&gt;age&lt;&#x2F;code&gt; to take on a default value of &lt;code&gt;0&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;jack = Person { name: &amp;quot;Baby Jack&amp;quot; }
&lt;&#x2F;span&gt;&lt;span&gt;jack.age
&lt;&#x2F;span&gt;&lt;span&gt;-------- this is 0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Whether this is a good idea or not is debatable, but it wouldn’t be too hard to write as a function:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;baby_person = { name } -&amp;gt; Person { name, age: 0 }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If &lt;code&gt;Person&lt;&#x2F;code&gt; accepted this as well, we’d write the type of the &lt;code&gt;Person&lt;&#x2F;code&gt; constructor function as:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;Person : { name: String, age: Nat }
&lt;&#x2F;span&gt;&lt;span&gt;       | { name: String, age: Nat, .. }
&lt;&#x2F;span&gt;&lt;span&gt;       | { name: String }
&lt;&#x2F;span&gt;&lt;span&gt;      -&amp;gt; Person
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let’s get a little crazy. Remember our &lt;code&gt;Wizards&lt;&#x2F;code&gt; from earlier? what if it was possible to construct a &lt;code&gt;Person&lt;&#x2F;code&gt; from a &lt;code&gt;Wizard&lt;&#x2F;code&gt;, you know, using our &lt;code&gt;wizard_to_person&lt;&#x2F;code&gt; routine:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;merlin = Wizard {
&lt;&#x2F;span&gt;&lt;span&gt;    title: &amp;quot;Wise&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    name:  &amp;quot;Merlin&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    skill: 930,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Person merlin
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This would mean that the &lt;code&gt;Person&lt;&#x2F;code&gt; constructor could really take anything of the following type:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;Person : { name: String, age: Nat }
&lt;&#x2F;span&gt;&lt;span&gt;       | { name: String, age: Nat, .. }
&lt;&#x2F;span&gt;&lt;span&gt;       | { name: String }
&lt;&#x2F;span&gt;&lt;span&gt;       | Wizard
&lt;&#x2F;span&gt;&lt;span&gt;       | ...
&lt;&#x2F;span&gt;&lt;span&gt;      -&amp;gt; Person
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In all these cases — wizards, row polymorphism, default parameters, or otherwise, what we’re trying to do is simple — treat a some type that isn’t a &lt;code&gt;Person&lt;&#x2F;code&gt; as a &lt;code&gt;Person&lt;&#x2F;code&gt; by extending the constructor. By extending the constructor, we’re essentially treating &lt;code&gt;Person&lt;&#x2F;code&gt; in the similitude of a trait: a common target for shared behavior, namely having a &lt;code&gt;name&lt;&#x2F;code&gt; and an &lt;code&gt;age&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In essence, we want &lt;em&gt;open membership&lt;&#x2F;em&gt; over &lt;code&gt;Person&lt;&#x2F;code&gt;’s constructor. What if we could define our own &lt;code&gt;Person T&lt;&#x2F;code&gt;, creating people from arbitrary people-likes of type &lt;code&gt;T&lt;&#x2F;code&gt;?&lt;&#x2F;p&gt;
&lt;p&gt;Something I’ve been considering is a &lt;code&gt;impl ... from&lt;&#x2F;code&gt; syntax, specifically for this purpose:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;-- So that `Person Wizard` works
&lt;&#x2F;span&gt;&lt;span&gt;impl Person from Wizard = 
&lt;&#x2F;span&gt;&lt;span&gt;    Wizard { title, name, skill } 
&lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; Person {
&lt;&#x2F;span&gt;&lt;span&gt;    name: &amp;quot;{name} the {title}&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    age:  25 + skill &#x2F; 10,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This, essentially, would add a case to &lt;code&gt;Person&lt;&#x2F;code&gt;’s constructor so that constructing a &lt;code&gt;Person&lt;&#x2F;code&gt; from a wizard now makes sense. This essentially acts as a form of dynamic dispatch!&lt;&#x2F;p&gt;
&lt;p&gt;In fact, we’re not limited to the second type being a named type. We could implement baby-by-default (the case where the default age is zero) in the following manner:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;impl Person from { name: String } =
&lt;&#x2F;span&gt;&lt;span&gt;    { name } -&amp;gt; Person { name, age: 0 }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which is pretty cool! There are lots of things you can do, like defining a &lt;code&gt;Default&lt;&#x2F;code&gt; type that wraps unit, &lt;code&gt;()&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;type Default = ()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can add a default implementation to person!&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;impl Person from Default 
&lt;&#x2F;span&gt;&lt;span&gt;    = Default -&amp;gt; Person {
&lt;&#x2F;span&gt;&lt;span&gt;        name: &amp;quot;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        age:  0,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So now it’s possible to write:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;Person Default
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Or use row splicing to fill in a &lt;code&gt;Person&lt;&#x2F;code&gt; from the &lt;code&gt;Default&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;ug = Person {
&lt;&#x2F;span&gt;&lt;span&gt;    name: &amp;quot;ug&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    .. Person Default,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Where &lt;code&gt;.. Person Default&lt;&#x2F;code&gt; essentially means fill the rest of this struct from &lt;code&gt;Person Default&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;But I guess you could argue that &lt;code&gt;Person&lt;&#x2F;code&gt; isn’t really a trait. Don’t we have this backwards? Wouldn’t we want to &lt;code&gt;impl Default from Person&lt;&#x2F;code&gt;, whatever that means?&lt;&#x2F;p&gt;
&lt;p&gt;Well yes and no. Let’s look at some iterators.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;iterators-in-passerine&quot;&gt;Iterators in Passerine&lt;&#x2F;h1&gt;
&lt;p&gt;So Passerine has a little problem, and it’s twofold:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;It only supports inductive datatypes (i.e. anything you could trivially serialize to JSON, no cycles).&lt;&#x2F;li&gt;
&lt;li&gt;Closures can only capture immutable values.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;In Rust we defined our type representing an iterator using, well, a mutable closure:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Iterator&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Item&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Box&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;dyn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;FnMut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Option&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Item&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So to model &lt;code&gt;Iterator&lt;&#x2F;code&gt; in Passerine, we’d essentially have to make the internal state explicit:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;type Iterator = all State Item -&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    state: State,
&lt;&#x2F;span&gt;&lt;span&gt;    _next: State -&amp;gt; Option (State, Item)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which isn’t too bad, because we can define a function &lt;code&gt;next&lt;&#x2F;code&gt; that operates on iterators, instead of calling &lt;code&gt;iterator._next&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;next : all S I 
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; (Iterator S I) 
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; Option (Iterator S I, T)
&lt;&#x2F;span&gt;&lt;span&gt;= Iterator { state, _next } -&amp;gt; match (_next state) {
&lt;&#x2F;span&gt;&lt;span&gt;    Some (new_state, item) -&amp;gt; Some (
&lt;&#x2F;span&gt;&lt;span&gt;        Iterator { state: new_state, _next }, 
&lt;&#x2F;span&gt;&lt;span&gt;        item,
&lt;&#x2F;span&gt;&lt;span&gt;    ),
&lt;&#x2F;span&gt;&lt;span&gt;    None -&amp;gt; None,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Aside:&lt;&#x2F;strong&gt; In the future, it might be possible to model hidden state using Passerine’s effect system.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Yeah, it kinda looks like a mess, and I invented some syntax, but bear with me.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s define an iterator, &lt;code&gt;Fib&lt;&#x2F;code&gt;, that we can use to calculate the fibonacci sequence:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;type Fib = ()
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;impl Iter (Nat, Nat) Nat for Fib = Fib -&amp;gt; Iter {
&lt;&#x2F;span&gt;&lt;span&gt;    state: (0, 1),
&lt;&#x2F;span&gt;&lt;span&gt;    _next: (a, b) -&amp;gt; Some ((a + b, a), a),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So our internal &lt;code&gt;State&lt;&#x2F;code&gt; is a pair of numbers &lt;code&gt;(Nat, Nat)&lt;&#x2F;code&gt;, and at each iteration we produce an &lt;code&gt;Item&lt;&#x2F;code&gt;, which is a number &lt;code&gt;Nat&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s say we define a function that takes an &lt;code&gt;Iter&lt;&#x2F;code&gt;, and prints out all its elements:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;println_all_iter = (iter: Iter) -&amp;gt; match (next iter) {
&lt;&#x2F;span&gt;&lt;span&gt;    None -&amp;gt; None,
&lt;&#x2F;span&gt;&lt;span&gt;    Some (new_iter, item) -&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        println item
&lt;&#x2F;span&gt;&lt;span&gt;        print_all_iter new_iter
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Printing out all the fibonacci numbers (warning!) is as easy as:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;println_all_iter (Iter (Fib ()))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which we can write using &lt;code&gt;|&amp;gt;&lt;&#x2F;code&gt; notation as follows:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;Fib () |&amp;gt; Iter |&amp;gt; println_all_iter
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;some-sugar&quot;&gt;Some sugar!&lt;&#x2F;h1&gt;
&lt;p&gt;Converting a &lt;code&gt;Wizard&lt;&#x2F;code&gt; to a &lt;code&gt;Person&lt;&#x2F;code&gt; is all well and good, but what if we just want a &lt;code&gt;Wizard&lt;&#x2F;code&gt;’s age? Currently, you’d have to do something like:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;(Person merlin).age
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which isn’t that bad. But what if we made &lt;code&gt;Type.field&lt;&#x2F;code&gt; sugar for &lt;code&gt;object -&amp;gt; (Type object).field&lt;&#x2F;code&gt;? Then the above would be:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;Person.age merlin
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which is reminiscent of a uniform function call syntax (UFCS), used to disambiguate when multiple traits are present.&lt;&#x2F;p&gt;
&lt;p&gt;Speaking of multiple traits…&lt;&#x2F;p&gt;
&lt;h1 id=&quot;disambiguating-multiple-traits&quot;&gt;Disambiguating Multiple Traits&lt;&#x2F;h1&gt;
&lt;p&gt;Currently, our functions can really only operate on one trait at a time. If our function accepts an &lt;code&gt;Iterator&lt;&#x2F;code&gt;, we can’t also specify that that type also implements the trait &lt;code&gt;Length&lt;&#x2F;code&gt;. Let’s take a second to flesh out this line of reasoning.&lt;&#x2F;p&gt;
&lt;p&gt;So we have two traits:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;type Iterator = ... -- see previous definition
&lt;&#x2F;span&gt;&lt;span&gt;type Length   = Nat -- the length of a collection
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can implement both &lt;code&gt;Iterator&lt;&#x2F;code&gt; and &lt;code&gt;Length&lt;&#x2F;code&gt; from a list &lt;code&gt;[T]&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;all T -&amp;gt; impl Iterator Nat T from [T] 
&lt;&#x2F;span&gt;&lt;span&gt;= list -&amp;gt; Iterator {
&lt;&#x2F;span&gt;&lt;span&gt;    state: 0
&lt;&#x2F;span&gt;&lt;span&gt;    _next: index -&amp;gt; if (list.length == index) {
&lt;&#x2F;span&gt;&lt;span&gt;        None
&lt;&#x2F;span&gt;&lt;span&gt;    } else {
&lt;&#x2F;span&gt;&lt;span&gt;        Some (index + 1)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;all T -&amp;gt; impl Length from [T] = list -&amp;gt; list.length
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let’s say we’re writing a function that takes an &lt;code&gt;Iterator&lt;&#x2F;code&gt; it needs to know the &lt;code&gt;Length&lt;&#x2F;code&gt; of. We &lt;em&gt;could&lt;&#x2F;em&gt; require the function to take both separately:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;println_half = iter length -&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    for _ in (length &#x2F; 2) {
&lt;&#x2F;span&gt;&lt;span&gt;        (iter, item) = next iter |&amp;gt; unwrap
&lt;&#x2F;span&gt;&lt;span&gt;        println item
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But this is bad because there’s no &lt;em&gt;requirement&lt;&#x2F;em&gt; that &lt;code&gt;length&lt;&#x2F;code&gt; is actually the length of &lt;code&gt;iter&lt;&#x2F;code&gt;. If we pass in an incorrect length, we could cause &lt;code&gt;println_half&lt;&#x2F;code&gt; to &lt;code&gt;unwrap&lt;&#x2F;code&gt; a &lt;code&gt;None&lt;&#x2F;code&gt; value! Aaaaaah!&lt;&#x2F;p&gt;
&lt;p&gt;Ideally, we’d want to be able to specify that &lt;code&gt;iter&lt;&#x2F;code&gt; implements both &lt;code&gt;Iterator&lt;&#x2F;code&gt; and &lt;code&gt;Length&lt;&#x2F;code&gt;. Let’s start by writing out the type of &lt;code&gt;println_half&lt;&#x2F;code&gt; as-is:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;println_half : all S I 
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; Iterator S I 
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; Nat 
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; ()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;One step we could take is just passing &lt;code&gt;iter&lt;&#x2F;code&gt; to &lt;code&gt;println_half&lt;&#x2F;code&gt; &lt;em&gt;twice&lt;&#x2F;em&gt;, and then constructing &lt;code&gt;Length&lt;&#x2F;code&gt; and &lt;code&gt;Iterator&lt;&#x2F;code&gt; once inside the function:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;println_half = list -&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    iter   = Iter list
&lt;&#x2F;span&gt;&lt;span&gt;    length = Length list
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for _ in (length &#x2F; 2) {
&lt;&#x2F;span&gt;&lt;span&gt;        (iter, item) = next iter |&amp;gt; unwrap
&lt;&#x2F;span&gt;&lt;span&gt;        println item
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we were to write this as a type, we’d need some way to say that &lt;code&gt;iter&lt;&#x2F;code&gt; implements &lt;em&gt;both&lt;&#x2F;em&gt; &lt;code&gt;Iterator&lt;&#x2F;code&gt; and &lt;code&gt;Length&lt;&#x2F;code&gt;. What would this type &lt;code&gt;???&lt;&#x2F;code&gt; be?&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;println_half : all S I
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; ???
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; ()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Rust already has a solution for this; it’s to use &lt;code&gt;+&lt;&#x2F;code&gt; to constrain a generic type to a trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;println_half&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T, U&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Iterator&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Item=T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt; +&lt;&#x2F;span&gt;&lt;span&gt; Length&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;list&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; U&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;) -&amp;gt; { ... }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here &lt;code&gt;U&lt;&#x2F;code&gt; represents a type that is both an &lt;code&gt;Iterator&lt;&#x2F;code&gt; and has a &lt;code&gt;Length&lt;&#x2F;code&gt;. I feel like we could adopt something like this for Passerine wholesale, but as Passerine’s generic story isn’t that strong yet (heck, I haven’t even decided on a syntax!), I wouldn’t want to overstretch the language in this manner.&lt;&#x2F;p&gt;
&lt;p&gt;One thing I have been working on, though, are type sets, in relation to Passerine’s effect system.&lt;&#x2F;p&gt;
&lt;p&gt;I’m not going to go into too much depth here, but for those familiar, under an effect system, functions may produce a set of side effects:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;print_random_number: () -&amp;gt; {Console, Random} () {
&lt;&#x2F;span&gt;&lt;span&gt;    random_number ()
&lt;&#x2F;span&gt;&lt;span&gt;    |&amp;gt; to_string
&lt;&#x2F;span&gt;&lt;span&gt;    |&amp;gt; println
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So &lt;code&gt;{Console, Random}&lt;&#x2F;code&gt; represents what side effects &lt;code&gt;print_random_number&lt;&#x2F;code&gt; causes. Because this is an effect &lt;em&gt;set&lt;&#x2F;em&gt;, &lt;code&gt;{A, B}&lt;&#x2F;code&gt;, is equivalent to &lt;code&gt;{B, A}&lt;&#x2F;code&gt;, and so on.&lt;&#x2F;p&gt;
&lt;p&gt;A &lt;em&gt;type set&lt;&#x2F;em&gt; could be a generalization of this to types. It’s the set of possible types another type implements as a trait. The type set of something that is iterable and has a length is:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;{Iterator, Length}
&lt;&#x2F;span&gt;&lt;span&gt;-- leaving out the generics
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which means we can treat anything of that type as both an &lt;code&gt;Iterator&lt;&#x2F;code&gt; and a &lt;code&gt;Length&lt;&#x2F;code&gt;, using a UFCS-like syntax (sugar) to disambiguate when necessary, as shown above.&lt;&#x2F;p&gt;
&lt;p&gt;So we could write the type of this updated &lt;code&gt;println_half&lt;&#x2F;code&gt; as follows:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;println_half : all S I
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; {Iterator S I, Length}
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; ()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which I think is fairly clean.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;something-deeper&quot;&gt;Something deeper?&lt;&#x2F;h1&gt;
&lt;p&gt;I think that this relationship between traits and algebraic effects is interesting. It’s something I’ve discussed with others in the past, and it’s something I’d like to continue to explore in the future.&lt;&#x2F;p&gt;
&lt;p&gt;When you think about it, effects are really just dynamically scoped traits; traits whose implementations change depending on dynamic, as opposed to lexically-resolved nominal, scope. &lt;&#x2F;p&gt;
&lt;p&gt;If Rust implemented algebraic effects, would they use &lt;code&gt;+&lt;&#x2F;code&gt; (as discussed earlier) and look like, well, traits? Makes me wonder…&lt;&#x2F;p&gt;
&lt;p&gt;I feel like there’s something deeper here. In essence, our trait system has boiled down to dynamic dispatch over conversion between types.&lt;&#x2F;p&gt;
&lt;p&gt;If I wanted a real trait system, I’d probably adopt HKTs and typeclasses. But part of designing a programming language is choosing a limiting set of axioms, and I think that having a separate language for type-level programming goes against Passerine’s design, which boils down to a functional scripting language. I’m already worried that typechecking will make Passerine take too long to compile; my goal is to have startup times as fast as something like Python.&lt;&#x2F;p&gt;
&lt;p&gt;I know that what I’ve been getting at — representing typeclasses as explicit datastructures — is nothing new, and has been common in both languages without higher-kinded types (such as F#, to get around limitations in the language), and languages with higher-kinded types (such as Agda, where types are just objects, so why couldn’t they be represented as ‘plain datastructures’?).&lt;&#x2F;p&gt;
&lt;p&gt;I feel like all languages in this area are slowly tending towards Agda. Then again, a while back it seemed like everything tended towards Scheme, so maybe it’s just a matter of perspective.&lt;&#x2F;p&gt;
&lt;p&gt;Anyway, I digress. I hope you found this little post interesting, thanks for reading!&lt;&#x2F;p&gt;
&lt;h1 id=&quot;one-last-note&quot;&gt;One last note&lt;&#x2F;h1&gt;
&lt;p&gt;I’ve noticed something interesting. When dealing with closed enumerations, we allow users of that closed enumeration to see any of the members that constitute that enumeration:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span&gt;TrafficLight &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    Red&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Yellow&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Green&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we match of traffic light, we can be sure to handle every pattern:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;TrafficLight&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::*;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;) -&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; String &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ff5370;&quot;&gt;self &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        Red &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&amp;gt; &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;red&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        Yellow &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&amp;gt; &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;yellow&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        Green &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&amp;gt; &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;green&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I want you to stop for a second an just realize that each match branch is a bit like a function. For example, the first branch takes an object of type &lt;code&gt;TrafficLight::Red&lt;&#x2F;code&gt; and returns a static string (&lt;code&gt;&amp;amp;&#x27;static str&lt;&#x2F;code&gt;). We could write this type out as:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;TrafficLight::Red -&amp;gt; &amp;amp;&amp;#39;static str
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So each match branch is really like a function, a closure. “Take the type that matches this pattern, produce this result”. Note that all match arms produce a result of the same type, so a &lt;code&gt;match&lt;&#x2F;code&gt; expression is a bit like a fan-out that compresses each possible branch into a single value.&lt;&#x2F;p&gt;
&lt;p&gt;So why do I bring this up now? Well, when you’re using an open enumeration, like a trait, &lt;em&gt;you can’t possibly know all the types that a value could be&lt;&#x2F;em&gt;. Behind the scenes, though, there’s still a massive match expression.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;&#x2F;&#x2F; `Named` trait
&lt;&#x2F;span&gt;&lt;span&gt;match type {
&lt;&#x2F;span&gt;&lt;span&gt;    Person =&amp;gt; ...
&lt;&#x2F;span&gt;&lt;span&gt;    Wizard =&amp;gt; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So when we implement a trait for yet another type, we’re really just adding another branch to the behind-the-scenes match expression. For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Named &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;TrafficLight &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;) -&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; String &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The method &lt;code&gt;name&lt;&#x2F;code&gt; is just a function of type &lt;code&gt;TrafficLight -&amp;gt; String&lt;&#x2F;code&gt;. Note the parallels here!&lt;&#x2F;p&gt;
&lt;p&gt;Under closed enumeration, we declare all the potential types (i.e. variants) up-front, and then match on these variants to extract common structure&#x2F;behavior:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; infinite number of behaviors
&lt;&#x2F;span&gt;&lt;span&gt;behavior &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; Closed &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; finite number of variants
&lt;&#x2F;span&gt;&lt;span&gt;    Variant &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; Dispatch&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Variant &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; Dispatch&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But under an open enumeration, there are possibly an infinite number of variants! So we declare all possible behaviors up front:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; infinite number of variants
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span&gt;Open &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; finite number of behaviors
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;behavior&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;() -&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; Dispatch&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Whenever we want to add a &lt;code&gt;Variant&lt;&#x2F;code&gt; to &lt;code&gt;Open&lt;&#x2F;code&gt;, we have to provide a match arm for each ‘behind-the-scenes’ &lt;code&gt;behavior&lt;&#x2F;code&gt; match expression:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Open &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Variant &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; This is just a match arm!
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;behavior&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;() -&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; Dispatch &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{ 
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So for each &lt;code&gt;behavior&lt;&#x2F;code&gt; in the &lt;code&gt;Open&lt;&#x2F;code&gt; enumeration, we provide a match arm: &lt;code&gt;Variant -&amp;gt; Dispatch&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The compiler stitches all these disparate match arms together to form these behind the scene match expressions:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; finite number of behaviors
&lt;&#x2F;span&gt;&lt;span&gt;behavior &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; Open &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; infinite number of variants
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Open &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Variant,
&lt;&#x2F;span&gt;&lt;span&gt;    impl Open for Variant,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Each implementation is like an opaque match arm.&lt;&#x2F;p&gt;
&lt;p&gt;To summarize:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Under closed enumerations, we have a finite number of variant branches; we must handle each branch while being able to implement arbitrarily many behaviors.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Under open enumerations, we have an infinite number of possible variant branches; to add a new variant, we must provide the ‘match-arms’ for a finite number of behaviors.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Now because open enumerations are defined around a finite set of behaviors, it makes sense that each variant &lt;em&gt;must&lt;&#x2F;em&gt; provide a function.&lt;&#x2F;p&gt;
&lt;p&gt;It is simply not possible to have both an infinite number of behaviors and an infinite number of variants. You can pick one or the other, and the structure of the resulting code will be affected by that decision.&lt;&#x2F;p&gt;
&lt;p&gt;I just love this parallel, and think that it drastically simplified my mental model of traits vs enums. &lt;&#x2F;p&gt;
&lt;p&gt;Traits as implicit conversion is essentially makes types open enumerations over the behavior of their constructor function. This model is really elegant because it reifies types and traits (we’re not ‘adding an extra layer’ to the language), but on the other hand it does complicate things somewhat.&lt;&#x2F;p&gt;
&lt;p&gt;I think this is honestly the pain of being a language designer. You get a &lt;em&gt;feeling&lt;&#x2F;em&gt; that there are these fundamental underlying constructs that underpin the way the world works. You spend a lot of time refining these feelings—writing them down, building prototypes—only to realize that everything old is new again, or that there are new cases you haven’t thought about that don’t neatly fit your model.&lt;&#x2F;p&gt;
&lt;p&gt;I wish there was just &lt;em&gt;a&lt;&#x2F;em&gt; language, a silver bullet, where these sorts of tradeoffs didn’t exist. A language where there was one single &lt;em&gt;obvious&lt;&#x2F;em&gt; way to implement something. A language where all semantic symmetries were wrapped up in symmetrical syntax, all constructs discovered through intuitive exploration and composition.&lt;&#x2F;p&gt;
&lt;p&gt;I know that this youthful idealism is unwarranted. The rubber has to hit the road somewhere, tradeoffs will always exist, and software is never developed alone. We need a Go of functional programming, whatever what that ends up looking like: a smaller Rust, a minimal Agda, a typed Scheme. &lt;&#x2F;p&gt;
&lt;p&gt;I can’t claim that Passerine will be that language. I’ve worked hard to engineer a minimal set of orthogonal features that &lt;em&gt;compose&lt;&#x2F;em&gt;. Once I’ve figured out how to unify effects and fibers (it’s mostly a matter of notation at this point), and have more cleanly delineated the line between the macro system and the type system, I think I may have an unstoppable seed of a language on my hands.&lt;&#x2F;p&gt;
&lt;p&gt;We’ll see where it goes from here :)&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Sketchnoting: a spontaneous but needed reflection</title>
		<published>2022-02-11T00:00:00+00:00</published>
		<updated>2022-02-11T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/blog/note/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/blog/note/</id>
		<content type="html">&lt;h1 id=&quot;preface&quot;&gt;Preface&lt;&#x2F;h1&gt;
&lt;p&gt;Since September of last year, I’ve been chipping away at a long-form post on how to take &lt;em&gt;good&lt;&#x2F;em&gt; notes. This, sadly, is not that post—consider this post a teaser to tide you over until then.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;content&#x2F;note-vols.jpg&quot; alt=&quot;Four filled notebooks and one new empty one.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Today I finished my fourth book of sketchnotes. Each book has about 240 blank A5 pages, so I guess I’m fast-approaching the thousand-page mark. In celebration of filling yet another volume, I took a trip down memory lane and dug out &lt;em&gt;Volumes 1-3&lt;&#x2F;em&gt;. Taking the time to read through some of my older notes, it’s easy to see that I’ve improved quite a lot.&lt;&#x2F;p&gt;
&lt;p&gt;While reading through my second notebook, though, I found a short hand-written collection of my thoughts on note-taking. Although it’s been a few years since then, I feel like the core of what I had to say then rings true today.&lt;&#x2F;p&gt;
&lt;p&gt;Below I’ve typed up those few pages of notes, I hope you find them interesting:&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;div class=&quot;boxed&quot;&gt;
&lt;h1 id=&quot;quality-and-quantity&quot;&gt;Quality and Quantity&lt;&#x2F;h1&gt;
&lt;div class=&quot;tag&quot;&gt;Written in early 2019&lt;&#x2F;div&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;content&#x2F;note-0.jpg&quot; alt=&quot;The first spread of sketchnotes from which this article was transcribed.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Over the past few months, I’ve noticed that I’ve grown lazy with my sketchnotes, and lost my sense of “quality” and style.&lt;&#x2F;p&gt;
&lt;p&gt;Over this past year I’ve practiced sketchnoting quite a lot, and have gotten a lot better at it. Yet I still fell as though I’m missing the mark.&lt;&#x2F;p&gt;
&lt;p&gt;Why is this? Have I started to rush? Gotten distracted? No, not really…&lt;&#x2F;p&gt;
&lt;h1 id=&quot;what-makes-good-sketchnotes&quot;&gt;What makes good sketchnotes?&lt;&#x2F;h1&gt;
&lt;p&gt;Taking good sketchnotes boils down to two things:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Filtering out all but the most important information&lt;&#x2F;li&gt;
&lt;li&gt;Putting it down on the page in a visually interesting, consistent, and unique manner.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The move I’ve taken notes, the more I’ve come to realize the stuff I used to think was important isn’t. The pens you use, paper you write on are nothing compared to the quality of your drawings and the relative importance of your thoughts.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;structuring-thought&quot;&gt;Structuring thought&lt;&#x2F;h1&gt;
&lt;p&gt;So how should good notes structure your thoughts?&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Structure based on key information.&lt;&#x2F;li&gt;
&lt;li&gt;Focus on drawing over writing.&lt;&#x2F;li&gt;
&lt;li&gt;Leverage to medium, group ideas by spacing.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;content&#x2F;note-1.jpg&quot; alt=&quot;The second spread of sketchnotes.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Note how not once I did I mention the quality of tools used, or the amount written. Good tools are important, yes, but they are not everything. So how can you accurately distill information? Some tips:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Listen before you write.&lt;&#x2F;li&gt;
&lt;li&gt;Draw before you annotate.&lt;&#x2F;li&gt;
&lt;li&gt;Don’t cram information where it doesn’t fit.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;How are these tips applied in practice?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;listen-before-you-write&quot;&gt;① Listen before you write&lt;&#x2F;h2&gt;
&lt;p&gt;If the primary goal of taking notes is remembering key points, then don’t confuse your future self by writing down things you don’t have to.&lt;&#x2F;p&gt;
&lt;p&gt;Take time to listen, extract, refine, plan, and write.&lt;&#x2F;p&gt;
&lt;p&gt;While you’re thinking, take time to refine previous notes, or draw out your thoughts on what you are currently listening to.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;draw-before-you-annotate&quot;&gt;② Draw before you annotate&lt;&#x2F;h2&gt;
&lt;p&gt;Ideas are inherently abstract; they’re a jumble of thoughts, emotion, purpose. Language, however, is less so… and as countless authors can tell you, putting your thoughts down onto paper is plenty hard.&lt;&#x2F;p&gt;
&lt;p&gt;To me, at least, drawings are an intermediary between abstract thought and formal language. Use drawings to refine your thoughts to a point where they can easily be written.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;don-t-cram-information-where-it-doesn-t-fit&quot;&gt;③ Don’t cram information where it doesn’t fit&lt;&#x2F;h2&gt;
&lt;p&gt;Time and time again, I’ve made the mistake of mis-spacing elements. I’ll think about something I’d like to add and cram it into the margins, completely interrupting the flow of my notes.&lt;&#x2F;p&gt;
&lt;p&gt;Before you write anything down, think about how it will affect the layout of other elements on the page. When you group things together on paper, you form a visual hierarchy. People group nearby elements when reading notes.&lt;&#x2F;p&gt;
&lt;p&gt;Take these squares, for example:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;content&#x2F;note-square.jpg&quot; alt=&quot;9 Squares arranged in a grid, then in rows, then in columns.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Each of these squares represents a thought. When they’re arranged together in a grid, all these thoughts are squished together. Unless very closely related, confusion reigns.&lt;&#x2F;p&gt;
&lt;p&gt;By arranging these squares into columns, you sacrifice some space in return for an obvious hierarchy that makes the progression of thoughts easier to follow later on. Note-taking is the art of turning perfect, absolute, chaotic ideas into imperfect partial representations. By using spacing and hierarchy, the relations between ideas can be naturally inferred.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;content&#x2F;note-2.jpg&quot; alt=&quot;The third and final spread of sketchnotes.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;&#x2F;h1&gt;
&lt;p&gt;Sketchnoting is not a perfect process. Don’t be afraid to make mistakes, as long as you make them correctly: take risks, learn from them. Do not only practice, but practice correctly: habits compound over time.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;h1 id=&quot;takeaways&quot;&gt;Takeaways&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;content&#x2F;note-lin.jpg&quot; alt=&quot;Holding a pen in hand, I sketchnote some Linear Algebra.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Recently I’ve been sketchnoting a lot of math (Linear Algebra and Multivariable Calculus). Compared to some other subjects, like english or history, math is a bit harder to sketchnote because it can be hard to come up with images that match the ideas you’re learning. Uncovering the underlying ‘story’ (usually obviously apparent in subjects like history) that links mathematical concepts is a harder challenge.&lt;&#x2F;p&gt;
&lt;p&gt;As I’ve sketchnoted more math, I’ve come to develop certain idioms and patterns that can be reused. Despite these notes being much better than the ones I took when first starting out, I feel as though I’m still missing the mark. I think that in the rush to capture everything, it’s easy to leave the core ideas out: the proofs and theorems that tie everything together.&lt;&#x2F;p&gt;
&lt;p&gt;Math aside, I think that what I noted about note-taking back then still rings true today. Good notes require active listening, distilling key concepts, then determining how to map those concepts onto a page. Skills learned through active note-taking make you more attentive and attuned to the world around you. There are lots of good guides to taking notes online, sure—but if you really want to get better at note-taking, there’s nothing more important than repeated practice and care.&lt;&#x2F;p&gt;
&lt;p&gt;So, what are you waiting for? Go take some notes!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;content&#x2F;note-meta.jpg&quot; alt=&quot;A sketch of some notes!&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Predicting the technology of 2027</title>
		<published>2022-01-04T00:00:00+00:00</published>
		<updated>2022-01-04T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/blog/2027/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/blog/2027/</id>
		<content type="html">&lt;p&gt;The other day, I was thinking about this question:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;What’s something that is not common today that you think will be really common 5 years from now?&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;As I do a lot of programming language design, I can’t help but think about what our tooling will be like in 5 years. I’m writing this in 2022, so here are some of my predictions for 2027, in no particular order:&lt;&#x2F;p&gt;
&lt;h1 id=&quot;copilot-co&quot;&gt;Copilot &amp;amp; co.&lt;&#x2F;h1&gt;
&lt;p&gt;First things first, although I strongly dislike (and don’t use) copilot, I think that AI-based code completion tools will become more and more common to the point of being indispensable. Recent advances in large language models reduce the attention complexity from &lt;code&gt;n²&lt;&#x2F;code&gt; to &lt;code&gt;n&lt;&#x2F;code&gt;, which means we’ll be seeing larger attention windows, and hence more concise code generation. &lt;&#x2F;p&gt;
&lt;p&gt;Additionally, work from Google on query-based models (models that have an external database) will be put to use, allowing for correct attribution as to where the model is generating its completion from, more up-to-date completions (model doesn’t have to be retrained, only database has to be updated), and more specific completions (using current codebase as database).&lt;&#x2F;p&gt;
&lt;h1 id=&quot;structured-tooling&quot;&gt;Structured Tooling&lt;&#x2F;h1&gt;
&lt;p&gt;With the rise of JetBrains, Tree-Sitter, and languages like Unison, I believe we’ll see more structured tooling; instead of modifying text, we’ll be working on entire ASTs. editors already do this to some degree, with completion, automatic bracket insertion, and indentation preservation, but I think tools for automatic semantic refactoring will become more prevalent. For this to happen I estimate that either a new plugin, editor, or LSP will be developed with support for all major languages.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;effects&quot;&gt;Effects&lt;&#x2F;h1&gt;
&lt;p&gt;Language-wise, there are some exciting features I see coming soon to a Language Near You™. The first one being a move towards algebraic effects for effect modeling. It turns out that a lot of language features—like control flow, concurrency, async&#x2F;await, yielding, exceptions, etc.—can be modeled in terms of effects. There’s a lot of potential here, and I think that either through libraries or (hopefully) language-level support, they’ll become more prevalent.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;gradual-typing&quot;&gt;Gradual Typing&lt;&#x2F;h1&gt;
&lt;p&gt;Noting the rise of TypeScript, I think we’ll also see the move towards languages that allow people to specify correctness in their programs over time. Functions can be written purely dynamically, like python, but over time type annotations can be added until you end up with strongly-typed programs a la Haskell. &lt;&#x2F;p&gt;
&lt;p&gt;Once a program is fully typed, there may be additional tools to prove the correctness of parts of a program. I don’t think this will be mainstream, but I think within 5 years tools like this will become more common and more ergonomic than they are today.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;machine-reinforcement-learning&quot;&gt;Machine&#x2F;Reinforcement Learning&lt;&#x2F;h1&gt;
&lt;p&gt;Aside from languages and tooling, I’d like to make some predictions within the field of ML. I predict we’ll see the creation of a language model that achieves above-human-expert performance on a number of text-based tasks. Some will say AI has passed human intelligence, others will say it’s only expert in a narrow context. Either way, they’re both forgetting that ‘AI’ will always be whatever humans &lt;em&gt;can&lt;&#x2F;em&gt; do that machines can &lt;em&gt;not&lt;&#x2F;em&gt; do yet. &lt;&#x2F;p&gt;
&lt;p&gt;I also think we’ll see the rise of more accurate and less data-intensive RL techniques that rely on attention-based trajectory prediction rather than PPO-like policy optimization. TL;DR is that we’ll become better at training models on tasks with low data availability for general optimization. Sadly, I think ML is moving away from open-source, and I think that most production models will be released as a blogpost + API instead of paper + code.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;games-raytracing-vr&quot;&gt;Games, Raytracing, VR&lt;&#x2F;h1&gt;
&lt;p&gt;With respect to games and graphics, real-time raytracing will become the norm. Aside from the increase in realism in games, as photorealism becomes more realistic, we’ll also see the move towards selective and stylistic games that use raytracing and PBR techniques to strongly enforce a non-PBR-like style. Real-time style transfer at high-resolutions may play an important role in this.&lt;&#x2F;p&gt;
&lt;p&gt;Oculus outsold XBox this year, which means that VR will become a lot bigger; your favorite VR game probably hasn’t been created yet. I generally dislike VR, but the technology is becoming a lot better. I just pray that the zuckerbergian dystopian metaverse doesn’t come to fruition and is usurped by a wider open-source protocol.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;&#x2F;h1&gt;
&lt;p&gt;I tried to be both optimistic yet honest in my above predictions. I don’t think there’s anything too surprising there for anyone entrenched in the field, but I’d really like to see how spot-on I was 5 years from now. Hey, maybe this’ll be a self-fulfilling prophecy.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Using Proof-of-Work to Manage Backpressure</title>
		<published>2021-12-01T00:00:00+00:00</published>
		<updated>2021-12-01T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/blog/dynamic-pow-backpressure/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/blog/dynamic-pow-backpressure/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;&#x2F;strong&gt; This is a quick piece that assumes some prior knowledge of PoW and backpressure. If you want to build up an intuition about backpressure before jumping in, you could read &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;@jayphelps&#x2F;backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7&quot;&gt;&lt;em&gt;this piece&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; or &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.tedinski.com&#x2F;2019&#x2F;03&#x2F;05&#x2F;backpressure.html&quot;&gt;&lt;em&gt;that one&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. If you’d like to learn more about PoW in the context of this article, check out &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hashcash&quot;&gt;&lt;em&gt;this article&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; (and &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Proof_of_work&quot;&gt;&lt;em&gt;that one as well&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;On the bus this afternoon, I was reading up on backpressure in distributed systems. Backpressure, long story short, is the backward force acting on data as it moves through a system.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;what-s-backpressure&quot;&gt;What’s Backpressure?&lt;&#x2F;h1&gt;
&lt;p&gt;Maintaining a healthy level of backpressure is important for creating a well-running system monolithic, microservice, distributed, or otherwise. Too little backpressure and services will be spending time idle waiting for work to arrive. Too much backpressure, on the other hand, can lead to a buildup of work and fatal system resets.&lt;&#x2F;p&gt;
&lt;p&gt;One of the first mistakes I made when first building distributed systems was not paying attention to the backpressure bottlenecks of the system. Although there are many ways to classify, manage, and build systems that main consistent backpressure, one system I want to focus on is proof-of-work based rate limiting.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;proof-of-work&quot;&gt;Proof of Work&lt;&#x2F;h1&gt;
&lt;p&gt;Proof-of-work (PoW) is nothing new. Now primarily associated with consensus mechanisms used BitCoin et al., PoW was first used an obscure email tool used to rate-limit spam and DoS attacks. In no small part due to the popularity of BitCoin, PoW has found a number of other uses.&lt;&#x2F;p&gt;
&lt;p&gt;I was prompted to write this post after re-reading the &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;pest.bitdash.io&#x2F;whitepaper.html&quot;&gt;Pest&lt;&#x2F;a&gt; specification, a distributed IRC-like protocol that uses PoW to maintain a steady influx of messages.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;managing-backpressure&quot;&gt;Managing Backpressure&lt;&#x2F;h1&gt;
&lt;p&gt;When managing backpressure, there are essentially two things that can be going wrong:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;You’re not receiving enough messages, meaning there’s probably a &lt;em&gt;bottleneck&lt;&#x2F;em&gt; somewhere else in the system.&lt;&#x2F;li&gt;
&lt;li&gt;You’re receiving too many messages, meaning &lt;em&gt;you’re&lt;&#x2F;em&gt; probably the bottleneck in the system.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;It’s important to remember that not all messages sent in a distributed system are necessary for the healthy operation of the system. When a service gets too stressed, services calling that service can reduce the number of messages they’re sending to improve the latency of the system (while maintaining consistent throughput).&lt;&#x2F;p&gt;
&lt;h1 id=&quot;pow-and-backpressure&quot;&gt;PoW and Backpressure&lt;&#x2F;h1&gt;
&lt;p&gt;The PoW Backpressure scheme I propose is pretty simple. Whenever a node—let’s call it the &lt;em&gt;client&lt;&#x2F;em&gt;—establishes a connection with a service it relies on—the &lt;em&gt;server&lt;&#x2F;em&gt;—the server returns a nonce and a work level for use in the next request. We’ll call this the &lt;em&gt;challenge&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;nonce&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;C9B76FBD&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;work&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;:  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To make a request, the client must complete the challenge. To do so, it must calculate the hash of the request it wants to send, append the nonce, and compute &lt;code&gt;N&lt;&#x2F;code&gt; rounds of proof of work (e.g. repeated hashing) until the specified work level has been met. The response and corresponding &lt;em&gt;proof&lt;&#x2F;em&gt; are then sent to the server for processing:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;nonce&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;C9B76FBD&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;N&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;:     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;456&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;req&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;:   { &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot; }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;PoW proofs are cheap to verify. If the server tries to validate the PoW and finds it to be invalid (incorrect &lt;code&gt;nonce&lt;&#x2F;code&gt; or incorrect &lt;code&gt;N&lt;&#x2F;code&gt;), it simply drops the message. If the proof is valid, however, the server unwraps the inner request &lt;code&gt;req&lt;&#x2F;code&gt; from the client and processes it as usual.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Aside:&lt;&#x2F;strong&gt; Whenever the server receives a message, it should &lt;em&gt;immediately&lt;&#x2F;em&gt; send a new challenge to the client.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Proof-of-work acts as a natural rate limiter of requests. It requires the client to do the bulk of the work creating a valid request. This is especially important in the context of untrusted distributed contexts, where it is easy to increase the work attackers need to perform without impacting the work the server needs to do to validate correctly formed packets.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;adjusting-the-rate-limit&quot;&gt;Adjusting the rate limit&lt;&#x2F;h1&gt;
&lt;p&gt;In the last section, we know how PoW can act as a rate limit. In this section I want to talk about adjusting that rate limit.&lt;&#x2F;p&gt;
&lt;p&gt;When the backpressure is too low, the work limit should be decreased; when it is to high, it should be increased. Say we have a queue of unprocessed requests &lt;code&gt;B&lt;&#x2F;code&gt;. We can set the backpressure as a function of the length of &lt;code&gt;B&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;Each successive work factor is twice as hard as the previous one: &lt;code&gt;2&lt;&#x2F;code&gt; is twice as much work as &lt;code&gt;1&lt;&#x2F;code&gt;, just as &lt;code&gt;11&lt;&#x2F;code&gt; is twice as much work as &lt;code&gt;10&lt;&#x2F;code&gt;. We can quantify the rate of incoming messages as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;js&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-js &quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;incoming &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;network_capacity &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;^ -&lt;&#x2F;span&gt;&lt;span&gt;work_factor)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So at a rate of &lt;code&gt;1000&lt;&#x2F;code&gt; messages per second when the work factor is &lt;code&gt;0&lt;&#x2F;code&gt;, changing the work factor to &lt;code&gt;3&lt;&#x2F;code&gt; would change the rate of incoming messages to &lt;code&gt;1000 * (1&#x2F;8)&lt;&#x2F;code&gt;, or &lt;code&gt;125&lt;&#x2F;code&gt;, messages per second.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s say we want to maintain a backpressure of &lt;code&gt;K&lt;&#x2F;code&gt; items in queue &lt;code&gt;B&lt;&#x2F;code&gt;, out of the length of our queue, &lt;code&gt;len(B)&lt;&#x2F;code&gt;. We know we can send &lt;code&gt;outgoing&lt;&#x2F;code&gt; messages per second, and can estimate the network capacity given the current work factor. To calculate the work factor we want to set, we could use something like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;js&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-js &quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;work_factor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;log_2&lt;&#x2F;span&gt;&lt;span&gt;((network_capacity &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;outgoing) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;(B) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;K))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This equation will try to match the throughput of the input, times some adjustment used to maintain constant backpressure. Let’s try out an example.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s say we’re receiving &lt;code&gt;1000&lt;&#x2F;code&gt; messages per second, we want &lt;code&gt;100&lt;&#x2F;code&gt; in queue, and we process &lt;code&gt;200&lt;&#x2F;code&gt; per second. Our queue currently has &lt;code&gt;800&lt;&#x2F;code&gt; messages in it. What should we set our work factor to be?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;js&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-js &quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;work_factor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;log_2&lt;&#x2F;span&gt;&lt;span&gt;((network_capacity &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;outgoing) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;(B) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;K))
&lt;&#x2F;span&gt;&lt;span&gt;work_factor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;log_2&lt;&#x2F;span&gt;&lt;span&gt;((            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;1000 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;200     &lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;(   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;800 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;work_factor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;log_2&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;40&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;work_factor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;5.32
&lt;&#x2F;span&gt;&lt;span&gt;work_factor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;5 &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; rounded
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once the target backpressure is restored, this work factor will decrease until a steady state is reached. Once the state is reached (i.e. &lt;code&gt;len(B) == K&lt;&#x2F;code&gt;), in the above example, the work factor will decrease to &lt;code&gt;2&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;js&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-js &quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;work_factor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;log_2&lt;&#x2F;span&gt;&lt;span&gt;((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;1000 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;200&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;100 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;)) &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; len(B) == K
&lt;&#x2F;span&gt;&lt;span&gt;work_factor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;log_2&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;work_factor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;2.32
&lt;&#x2F;span&gt;&lt;span&gt;work_factor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; rounded
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This work factor is quick to calculate and will adjust to automatically. For &lt;em&gt;servers&lt;&#x2F;em&gt; that can scale horizontally, it can also be a good metric as to when to spin up more instances (if you want to maintain low latency without rate limiting your users).&lt;&#x2F;p&gt;
&lt;h1 id=&quot;dynamic-rate-limiting&quot;&gt;Dynamic Rate Limiting&lt;&#x2F;h1&gt;
&lt;p&gt;There is nothing that requires that PoW be universal across all clients. Servers can be selective and choose to increase work for IPs exhibiting DoS-like behavior, clients sending too many messages, or untrusted clients in a distributed network.&lt;&#x2F;p&gt;
&lt;p&gt;There’s a lot more that can be explored now, but it’s getting late and I value my sleep. :P&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;I hope you’ve found this little piece interesting. If you’re ever dealing with managing backpressure, I hope that you’ll find PoW-based rate limiting to be a useful tool in your toolbox. Until next time!&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Thinking about efficient backing stores for CRDTs</title>
		<published>2021-08-02T00:00:00+00:00</published>
		<updated>2021-08-02T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/blog/backing-crdt-store/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/blog/backing-crdt-store/</id>
		<content type="html">&lt;p&gt;A &lt;em&gt;Conflict-Free Replicated Datatype&lt;&#x2F;em&gt; is a bit like a smoothie: the same ingredients will produce the same result, regardless of the order in which they are added. In the context of, say, text editing in a distributed context, merging two documents will always succeed in a deterministic manner. In other words, A CRDT is a bit like a git repository that never has merge conflicts.&lt;&#x2F;p&gt;
&lt;p&gt;There are many different ways to approach the construction of CRDTs, each construction having its own strengths and weaknesses. Today, we’re going to focus on creating out an efficient backing store for a particular family of algorithms known as &lt;em&gt;Replicated Growth Arrays&lt;&#x2F;em&gt; (RGA).&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;Before we begin, though, I guess I should establish my motivation for writing this piece. I can’t begin to think about CRDTs without also considering distributed network topologies, and peer-to-peer collaboration. My goal, for this article, is to lay out the skeleton of a backing store for CRDTs that is both easy to work with in-memory and easy to replicate over the network. I hope you’ll see how the solution I derive addresses both these goals.&lt;&#x2F;p&gt;
&lt;p&gt;Under RGA, we represent documents as trees of strings. If this sounds familiar, that because it’s a bit like a &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rope_&quot;&gt;Rope&lt;&#x2F;a&gt;. To ensure that these trees always merge, we provide an algorithm for merging two trees together in a deterministic manner.&lt;&#x2F;p&gt;
&lt;p&gt;The merging algorithm behind RGA is pretty elegant. Each character in the tree points to the one before it. If two characters have the same parent, we order them from back to front, the latest character going first (sorting by user in case of a tie).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;content&#x2F;crdt-rga.svg&quot; alt=&quot;An image of an RGA tree spelling out the word “Cat!”&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In the above example, Bob typed &lt;code&gt;C!&lt;&#x2F;code&gt;. Later, Mia slides in and makes a two character edit by inserting the letters &lt;code&gt;at&lt;&#x2F;code&gt; after &lt;code&gt;C&lt;&#x2F;code&gt;, so the document now reads &lt;code&gt;Cat!&lt;&#x2F;code&gt;. When Bob synchronizes her changes, they’re inserted before the &lt;code&gt;!&lt;&#x2F;code&gt;, because her edits happened happened later. Now both Bob and Mia have &lt;code&gt;Cats!&lt;&#x2F;code&gt; on their screen!&lt;&#x2F;p&gt;
&lt;p&gt;Note that although &lt;em&gt;conceptually&lt;&#x2F;em&gt; RGA operates on trees, implementation-wise, it’s not a requirement. Trees are an inefficient substrate for RGA for a number of reasons, the largest being wasted space and the fact that they don’t play well with the L1 cache. If we flatten the tree out into a list (still inefficient for other reasons), the RGA insertion algorithm discussed above looks something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; Adapted from https:&#x2F;&#x2F;josephg.com&#x2F;blog&#x2F;crdts-go-brrr&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; Insert an edit (the `Entry`) into a CRDT (`self`)
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;automerge_insert&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;entry&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span&gt;Entry&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; (1) Insert at least after parent
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; parent_index &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ff5370;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;find_item&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;entry&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;parent&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; index &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ff5370;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;contents&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; parent_index&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ff5370;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;contents&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; (2) Compare to later entries
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; old_entry &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ff5370;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;contents&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;i&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; entry&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;seq &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; old_entry&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;seq &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{&lt;&#x2F;span&gt;&lt;span&gt; index &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; i&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;; }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; old_parent_index &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ff5370;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;find_item&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;old_entry&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;parent&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; Check if this is the right spot
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; old_parent_index &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; parent_index
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;|| (&lt;&#x2F;span&gt;&lt;span&gt;old_parent_index &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span&gt; parent_index
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;amp;&amp;amp; (&lt;&#x2F;span&gt;&lt;span&gt;entry&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;seq &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span&gt; old_entry&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;seq&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; entry&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;id &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; old_entry&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;id
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;) {&lt;&#x2F;span&gt;&lt;span&gt; index &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; i&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;; }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; (3) Insert entry at the right spot
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ff5370;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;contents&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;index&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; entry&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I’m not going to go into how this works in a lot of detail (If you’d like to, take a look at &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;josephg.com&#x2F;blog&#x2F;crdts-go-brrr&#x2F;&quot;&gt;this&lt;&#x2F;a&gt;!). But there are a few things I think are important to note.&lt;&#x2F;p&gt;
&lt;p&gt;Each of the numbered comments (&lt;code&gt;(1)&lt;&#x2F;code&gt;, etc.) annotates a performance-critical or otherwise common operation. Based on these requirements, we can derive a decent picture of what a good backing data structure should look like:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;When we call &lt;code&gt;self.find_item(...)&lt;&#x2F;code&gt;, we’re trying to lookup the index of an id. Thus, this algorithm needs a backing data structure where entries can be found quickly by key.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Later, in &lt;code&gt;self.contents[i]&lt;&#x2F;code&gt; we iterate through the array in a sequential manner by index. For this reason, the data structure must be ordered, indexable, and easy to iterate through.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Finally, we need to actually perform the insertion. &lt;code&gt;self.contents.insert(index, entry)&lt;&#x2F;code&gt; does the trick, but this is a very slow operation for arrays as all later elements must be reallocated. A good data structure should support efficient insertion of new elements.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;In the above example, we’re using a Rust &lt;code&gt;Vec&lt;&#x2F;code&gt;, which is a dynamically growable array. Vectors are really efficient in cache, but as mentioned, horrifically slow for insertion (which requires reallocation) or indexing by key (an &lt;code&gt;O(n)&lt;&#x2F;code&gt; linear search).&lt;&#x2F;p&gt;
&lt;p&gt;In light of this, a few people have come up with better backing data structures that exist the fill the gap. Most of these are build around Ropes or Range Trees. These work great in practice, but still have some overhead when looking up entries by key or storing many small edits.&lt;&#x2F;p&gt;
&lt;p&gt;I’ve been thinking about this issue for the past few days, and I think I have an interesting possible solution. I’m no expert, but I do have some experience with OT and optimization, so we’ll see how it goes. I’m calling this solution a &lt;em&gt;Backed Tree Log&lt;&#x2F;em&gt;, and it functions as an append-only log + a backing key-value tree for efficient key lookup. Here’s what that looks like:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Revised up to here&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;backed-tree-log&quot;&gt;Backed Tree Log&lt;&#x2F;h2&gt;
&lt;p&gt;Each &lt;em&gt;item&lt;&#x2F;em&gt; in the CRDT is uniquely uniquely identified by an &lt;em&gt;ID&lt;&#x2F;em&gt;. For our purposes, IDs will be represented as three-tuples of a user’s ID (or public key), the index of the item’s &lt;code&gt;Entry&lt;&#x2F;code&gt;, and the specific &lt;em&gt;sub-item&lt;&#x2F;em&gt; within that &lt;code&gt;Entry&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; User is also a usize under the hood
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; User, entry index, sub-item index
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Id&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;User, &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There’s an important distinction to be made between entries and items. An item is something atomic, like a character in a string or an &lt;em&gt;item&lt;&#x2F;em&gt; in a list. An entry is a group of items that were created at a similar time or place.&lt;&#x2F;p&gt;
&lt;p&gt;The way I find easiest to conceptualize the distinction between items and entries is as follows: instead of storing individual &lt;em&gt;letters&lt;&#x2F;em&gt; in a text CRDT, for instance, we store &lt;em&gt;runs&lt;&#x2F;em&gt; of letters as &lt;em&gt;strings&lt;&#x2F;em&gt;. Each &lt;em&gt;entry&lt;&#x2F;em&gt; operates on the level of runs, rather than at the base level of letters. Although we’re grouping items together in entries, each letter is accessible as its own item.&lt;&#x2F;p&gt;
&lt;p&gt;So, an &lt;code&gt;Entry&lt;&#x2F;code&gt; is an edit, which may refer to a group of items. In addition to this, it contains enough information about the surrounding nodes to be able to construct a full graph from it (if needed). &lt;code&gt;seq&lt;&#x2F;code&gt; is the sequence number, i.e. timestamp for when the entry was inserted, and should be increased by the length of the entry so each item in the Tree Log has it’s own index and sequence number. Here’s the definition:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Entry &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    start&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:  &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    length&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    parent&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; Id,
&lt;&#x2F;span&gt;&lt;span&gt;    seq&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;usize
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As mentioned earlier, it’s important to note that an entry represents a run of items. To ensure we don’t waste space by allocating a separate collection for each entry, all items are stored together in a larger in collection. A UTF-8 encoded &lt;code&gt;String&lt;&#x2F;code&gt; may be used as a backing store for some text, likewise, a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; may be used as a backing store for an arbitrary list of items &lt;code&gt;T&lt;&#x2F;code&gt;. To disambiguate what items a particular entry is referring to, we use &lt;code&gt;start&lt;&#x2F;code&gt; and &lt;code&gt;length&lt;&#x2F;code&gt; to keep track of the location of the slice within the larger collection.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Why not &lt;code&gt;start&lt;&#x2F;code&gt; and &lt;code&gt;end&lt;&#x2F;code&gt;? By using &lt;code&gt;start&lt;&#x2F;code&gt; and &lt;code&gt;length&lt;&#x2F;code&gt;, we can ensure that &lt;code&gt;end&lt;&#x2F;code&gt; is never less than start. I think it’s easier to write correct code when invalid states are hard to represent in general.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;For each &lt;code&gt;User&lt;&#x2F;code&gt; in the CRDT, we keep track of a column, that looks something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Column&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    user&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;    User,
&lt;&#x2F;span&gt;&lt;span&gt;    backing&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; T,
&lt;&#x2F;span&gt;&lt;span&gt;    entries&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Entry&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;backing&lt;&#x2F;code&gt;, of course, is something that can be indexed and appended to, like a &lt;code&gt;String&lt;&#x2F;code&gt; or a &lt;code&gt;Vec&lt;&#x2F;code&gt;. Whenever we create a new entry, we append the contents onto &lt;code&gt;backing&lt;&#x2F;code&gt; (or look them up if they already exist in &lt;code&gt;backing&lt;&#x2F;code&gt; - more on that later) and include the &lt;code&gt;start&lt;&#x2F;code&gt; and &lt;code&gt;length&lt;&#x2F;code&gt; of those contents with respect to &lt;code&gt;backing&lt;&#x2F;code&gt;. It’s important to note that both &lt;code&gt;backing&lt;&#x2F;code&gt; and &lt;code&gt;entries&lt;&#x2F;code&gt; are append-only. This makes it insanely trivial to synchronize over the network - just send what’s been added - and can be cryptographically signed and verified using a backing merkle tree, a la DAT.&lt;&#x2F;p&gt;
&lt;p&gt;Remember that the second field of &lt;code&gt;Id&lt;&#x2F;code&gt; contains the &lt;em&gt;index&lt;&#x2F;em&gt; of an &lt;code&gt;Entry&lt;&#x2F;code&gt; in a &lt;code&gt;Column&lt;&#x2F;code&gt;. This means that, given an &lt;code&gt;Id&lt;&#x2F;code&gt;, we can locate the corresponding &lt;code&gt;Entry&lt;&#x2F;code&gt; in &lt;code&gt;O(1)&lt;&#x2F;code&gt; time. But how to we preserve order?&lt;&#x2F;p&gt;
&lt;p&gt;We use a set of &lt;code&gt;Columns&lt;&#x2F;code&gt; to form a &lt;code&gt;TreeLog&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;TreeLog&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; could use a BTreeMap instead
&lt;&#x2F;span&gt;&lt;span&gt;    columns&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span&gt;HashMap&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;User, Column&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    tree&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:    &lt;&#x2F;span&gt;&lt;span&gt;RangeMap&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Id&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As mentioned earlier, we need a way to &lt;em&gt;order&lt;&#x2F;em&gt; every entry, so it’s fast to index into the datastructure. To do this, we build a backing &lt;code&gt;RangeMap&lt;&#x2F;code&gt;. This &lt;code&gt;RangeMap&lt;&#x2F;code&gt; stores the &lt;code&gt;Id&lt;&#x2F;code&gt; of each entry, across multiple users, in total order. Thus, both traversing the CRDT by &lt;code&gt;Id&lt;&#x2F;code&gt; in order, and being able to quickly index into the tree in a reasonable amount of time (&lt;code&gt;O(log N)&lt;&#x2F;code&gt;) become feasible.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;takeaways&quot;&gt;Takeaways&lt;&#x2F;h2&gt;
&lt;p&gt;Returning to our three original goals:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;A backing data structure in which entries can be found quickly by key. We do this through an append-only log, identified by index.&lt;&#x2F;li&gt;
&lt;li&gt;Must also be ordered, and easy to iterate through. We do this through an auxiliary Range Map.&lt;&#x2F;li&gt;
&lt;li&gt;Must support efficient insertion of new elements. The log is append-only, and insertion is fast for Range Maps.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The auxiliary range map can be built entirely from the content of &lt;code&gt;columns&lt;&#x2F;code&gt;, through a modified version of &lt;code&gt;automerge_insert&lt;&#x2F;code&gt;. I think I’d call this &lt;code&gt;automerge_sort&lt;&#x2F;code&gt;, as it’s building an ordered tree by performing a merge sort across all columns. I might right a bit more about this algorithm in the future.&lt;&#x2F;p&gt;
&lt;p&gt;It’s also good to know that traditional CRDT operations, like insertion, deletion, etc. do not require a full rebuild of either the &lt;code&gt;tree&lt;&#x2F;code&gt; or the columns in it - i.e. both can be updated in a reliable manner, whether that be via insertion, or through some other mechanism.&lt;&#x2F;p&gt;
&lt;p&gt;This whole spiel is CPU-friendly, of course. Almost all data is stored in cache-friendly &lt;code&gt;Vec&lt;&#x2F;code&gt;s; Range Maps, although less ideal, will be smaller than usual when compared to the way they’re &lt;em&gt;usually&lt;&#x2F;em&gt; used as the only backing store for CRDTs.&lt;&#x2F;p&gt;
&lt;p&gt;Also, note that the generic &lt;code&gt;T&lt;&#x2F;code&gt; is not an individual entry, but a &lt;em&gt;collection&lt;&#x2F;em&gt; that can be indexed into. We do this so we can put everything into a single backing store per-user. To uphold the CRDT invariant that everything must have a unique ID and sequence number, when inserting we increment the sequence number by the length of the entry.&lt;&#x2F;p&gt;
&lt;p&gt;I hope what I’ve presented makes some sense, I just wanted to get my heads out of my head and onto proverbial paper. If you’re interested in what becomes of this project, I’ve put a &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;slightknack&#x2F;together&#x2F;&quot;&gt;GitHub repo up&lt;&#x2F;a&gt; that contains some preliminary work, and is where I plan to explore the idea further.&lt;&#x2F;p&gt;
&lt;p&gt;Dear reader, you’ve reached the end!&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO: Incorporate Lamport timestamp as discussed with 02Keith&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Getting bindgen working on NixOS</title>
		<published>2021-07-08T00:00:00+00:00</published>
		<updated>2021-07-08T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/blog/nix-os-bindgen/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/blog/nix-os-bindgen/</id>
		<content type="html">&lt;blockquote&gt;
&lt;h1 id=&quot;note&quot;&gt;Note&lt;&#x2F;h1&gt;
&lt;p&gt;this is a collection of a set of discord messages sent on the NixOS discord server.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;troubles-w-nixos&quot;&gt;Troubles w&#x2F; NixOS&lt;&#x2F;h1&gt;
&lt;p&gt;I’m back! This is a hard one, I swear, and I’ve been banging my head against it for hours: I’m trying to compile a rust library that wraps &lt;code&gt;libcec&lt;&#x2F;code&gt;. To wrap &lt;code&gt;libc&lt;&#x2F;code&gt;, this library uses &lt;code&gt;bindgen&lt;&#x2F;code&gt;. Here’s what the crate roughly looks like:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;.
&lt;&#x2F;span&gt;&lt;span&gt;├── build.rs
&lt;&#x2F;span&gt;&lt;span&gt;├── Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;└── src
&lt;&#x2F;span&gt;&lt;span&gt;    ├── lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;    └── wrapper.h
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Two important things to note: &lt;code&gt;build.rs&lt;&#x2F;code&gt; invokes bindgen, doing something like the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;bindgen&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt;Builder&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt;default&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;header&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;src&#x2F;wrapper.h&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;generate&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And &lt;code&gt;wrapper.h&lt;&#x2F;code&gt; is just a simple header that includes &lt;code&gt;libcec&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;libcec&#x2F;cecc.h&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;On most operating systems, clang or whatever leafs through well-known &lt;code&gt;include&lt;&#x2F;code&gt; locations to toss together a big ol’ binary salad. NixOS, of course, loathes this. So, upon trying to compile this crate via &lt;code&gt;cargo build&lt;&#x2F;code&gt;, we get an error, sensibly enough:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;src&#x2F;wrapper.h:1:10: fatal error: &amp;#39;libcec&#x2F;cecc.h&amp;#39; file not found
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;No problemo! We can use &lt;code&gt;.clang_arg(...)&lt;&#x2F;code&gt; to send clang some args about where to look for &lt;code&gt;include&lt;&#x2F;code&gt; locations. Here’s an example that works with macOS, say:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;bindgen::Builder::default()
&lt;&#x2F;span&gt;&lt;span&gt;    .header(&amp;quot;src&#x2F;wrapper.h&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;    .clang_arg(&amp;quot;-I&#x2F;usr&#x2F;local&#x2F;include&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So we just need to find the include location for &lt;code&gt;libcec&lt;&#x2F;code&gt; on NixOS, right? tossing this into our &lt;code&gt;shell.nix&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nix&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-nix &quot;&gt;&lt;code class=&quot;language-nix&quot; data-lang=&quot;nix&quot;&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;# ...
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;LIBCEC_PATH&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#ff5370;color:#ffffff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#89ddff;&quot;&gt;${&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#f78c6c;&quot;&gt;libcec&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#89ddff;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;&#x2F;include&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#ff5370;color:#ffffff;&quot;&gt;;&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We then &lt;em&gt;should&lt;&#x2F;em&gt; be able to specify the right include location:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;.clang_arg(&amp;quot;-I$LIBCEC_PATH&amp;quot;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Huh, this doesn’t work, same error as before:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;src&#x2F;wrapper.h:1:10: fatal error: &amp;#39;libcec&#x2F;cecc.h&amp;#39; file not found
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Well, we can always just skip the wrapper and pull in the header file directly, right? Let’s echo &lt;code&gt;$LIBCEC_PATH&lt;&#x2F;code&gt; to find where in the heavens above &lt;code&gt;libcec&lt;&#x2F;code&gt; is, locate the header file, then schloop that in:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;$ tree $LIBCEC_PATH
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;nix&#x2F;store&#x2F;klsqc20n71gja5b8sa9ncw1jl6lcaxw9-libcec-6.0.2&#x2F;include
&lt;&#x2F;span&gt;&lt;span&gt;└── libcec
&lt;&#x2F;span&gt;&lt;span&gt;    ├── cecc.h
&lt;&#x2F;span&gt;&lt;span&gt;    └── ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There it is!&lt;&#x2F;p&gt;
&lt;p&gt;I know this isn’t best practice, but let’s use this as the path to the header file we want in &lt;code&gt;build.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;bindgen&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt;Builder&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt;default&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;header&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;&#x2F;nix&#x2F;store&#x2F;klsqc20n71gja5b8sa9ncw1jl6lcaxw9-libcec-6.0.2&#x2F;include&#x2F;libcec&#x2F;cecc.h&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It’s not the prettiest, but it should work, right? … uh… right… ?&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;$ cargo build
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;nix&#x2F;store&#x2F;klsqc20n71gja5b8sa9ncw1jl6lcaxw9-libcec-6.0.2&#x2F;include&#x2F;libcec&#x2F;cectypes.h:38:10:
&lt;&#x2F;span&gt;&lt;span&gt;fatal error: &amp;#39;stdint.h&amp;#39; file not found
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Drat! Foiled again! It seems NixOS is too clever for me. This time the entirety of &lt;code&gt;libc&lt;&#x2F;code&gt; has gone missing!&lt;&#x2F;p&gt;
&lt;p&gt;At this point, I spent about another few hours trying to get &lt;code&gt;libc&lt;&#x2F;code&gt; to show up. I also read a ton (e.g. &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;nixos.wiki&#x2F;wiki&#x2F;C&quot;&gt;C on Nix wiki&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gnulib&#x2F;manual&#x2F;html_node&#x2F;stdint_002eh.html&quot;&gt;stdint in gnulibc manual&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;issues?q=is%3Aissue+stdint.h+&quot;&gt;NixOS issue related to stdint&lt;&#x2F;a&gt;, etc.) to no avail.&lt;&#x2F;p&gt;
&lt;p&gt;So here’s my question: What am I doing wrong? How can I use &lt;code&gt;bindgen&lt;&#x2F;code&gt; to wrap a c library in a crate? If you need any additional information, ping me and I’ll send it right over! Thank you!&lt;&#x2F;p&gt;
&lt;h1 id=&quot;update-an-incredible-solution&quot;&gt;Update! An incredible solution&lt;&#x2F;h1&gt;
&lt;p&gt;Shortly after I posted this, I reached out to &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Siraben&quot;&gt;Ben Siraphob&lt;&#x2F;a&gt;, a good friend of mine who convinced me to try out NixOS in the first place. We hopped on a call together, and he showed me how to reach a solution. Credit for the solution goes to him, I was in way over my head!&lt;&#x2F;p&gt;
&lt;p&gt;So, what was the solution, anyway? After searching for similar packages on Nixpkgs, we found that this issue itself was pretty uncommon (go figure). Luckily enough for us, it looked like the derivations of Firefox (I think?) and about two other projects had to deal with linking against evasive c library headers.&lt;&#x2F;p&gt;
&lt;p&gt;The first order of business was switching out &lt;code&gt;shell.nix&lt;&#x2F;code&gt; for a proper derivation. because it’s a Rust project we’re compiling, it’s best to use &lt;code&gt;rustPlatform.buildRustPackage&lt;&#x2F;code&gt;. After declaring the package and including it’s SHA, the first thing we needed to do was make sure &lt;code&gt;LIBCLANG&lt;&#x2F;code&gt; was in the right spot and could be found. This is simple enough:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nix&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-nix &quot;&gt;&lt;code class=&quot;language-nix&quot; data-lang=&quot;nix&quot;&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;rustPlatform&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;buildRustPackage &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;rec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;# ...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;LIBCLANG_PATH &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#89ddff;&quot;&gt;${&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#f78c6c;&quot;&gt;llvmPackages&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#f78c6c;&quot;&gt;libclang&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#f78c6c;&quot;&gt;lib&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#89ddff;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;&#x2F;lib&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;# ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Next thing we needed to do was pass in some c flags to bindgen. I’m not too sure what these do, but they’re what was used by Firefox and they seem to work:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;configurePhase = &amp;#39;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;  BINDGEN_CFLAGS=&amp;quot;$(&amp;lt; ${stdenv.cc}&#x2F;nix-support&#x2F;libc-crt1-cflags) \
&lt;&#x2F;span&gt;&lt;span&gt;    $(&amp;lt; ${stdenv.cc}&#x2F;nix-support&#x2F;libc-cflags) \
&lt;&#x2F;span&gt;&lt;span&gt;    $(&amp;lt; ${stdenv.cc}&#x2F;nix-support&#x2F;cc-cflags) \
&lt;&#x2F;span&gt;&lt;span&gt;    $(&amp;lt; ${stdenv.cc}&#x2F;nix-support&#x2F;libcxx-cxxflags) \
&lt;&#x2F;span&gt;&lt;span&gt;    ${lib.optionalString stdenv.cc.isClang &amp;quot;-idirafter ${stdenv.cc.cc.lib}&#x2F;lib&#x2F;clang&#x2F;${lib.getVersion stdenv.cc.cc}&#x2F;include&amp;quot;} \
&lt;&#x2F;span&gt;&lt;span&gt;    ${lib.optionalString stdenv.cc.isGNU &amp;quot;-isystem ${lib.getDev stdenv.cc.cc}&#x2F;include&#x2F;c++&#x2F;${lib.getVersion stdenv.cc.cc} -isystem ${stdenv.cc.cc}&#x2F;include&#x2F;c++&#x2F;${lib.getVersion stdenv.cc.cc}&#x2F;${stdenv.hostPlatform.config}&amp;quot;} \
&lt;&#x2F;span&gt;&lt;span&gt;    $NIX_CFLAGS_COMPILE&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  export OUT=${placeholder &amp;quot;out&amp;quot;}
&lt;&#x2F;span&gt;&lt;span&gt;  echo $OUT
&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&amp;#39;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which is a lot, but it isn’t a lot a lot. But wait! how does Rust know where libcec is during compilation? obviously hardcoding something in the &lt;code&gt;store&lt;&#x2F;code&gt; is a bad idea!&lt;&#x2F;p&gt;
&lt;p&gt;During the patch phase (which happens before the configuration phase seen above), we can perform a substitution. In &lt;code&gt;build.rs&lt;&#x2F;code&gt;, we can switch out the builder to be:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; bindings &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;bindgen&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt;Builder&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt;default&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;header&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;LIBCEC_HEADERS&#x2F;include&#x2F;libcec&#x2F;cecc.h&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And then substitute out LIBCEC_HEADERS with the path to the actual headers:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nix&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-nix &quot;&gt;&lt;code class=&quot;language-nix&quot; data-lang=&quot;nix&quot;&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;patchPhase &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#ff5370;color:#ffffff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;#39;&amp;#39;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;  substituteInPlace build.rs --replace &amp;quot;LIBCEC_HEADERS&amp;quot; &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#89ddff;&quot;&gt;${&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#f78c6c;&quot;&gt;libcec&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#89ddff;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;#39;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#ff5370;color:#ffffff;&quot;&gt;;&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This seems like a bit of a hack, but hey, at least it works! Last but not least, we can set our build inputs, and…&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;nativeBuildInputs = [
&lt;&#x2F;span&gt;&lt;span&gt;  llvmPackages.clang
&lt;&#x2F;span&gt;&lt;span&gt;  tree
&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;buildInputs = [
&lt;&#x2F;span&gt;&lt;span&gt;  libcec glibc
&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Tada! Everything works as intended! There’s a little cleanup that needs to be done to extract the resulting Rust binary, but I’ll spare you the details.&lt;&#x2F;p&gt;
&lt;p&gt;NixOS is pretty cool, but it seems to be targeted towards people who like to roll their own solutions and stick to open source software. This is great! If you do decide to go all in, though, be prepared!&lt;&#x2F;p&gt;
&lt;p&gt;Thanks again to everyone who helped me resolve this issue! Nix has shown me how many assumptions are present when building modern software, and it’s surprising how good of a job they’ve done categorizing different issues and dependencies and making reproducible builds as easy as &lt;code&gt;nix build&lt;&#x2F;code&gt;. ’Til next time!&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Macros, Types, and Next Steps</title>
		<published>2021-06-01T00:00:00+00:00</published>
		<updated>2021-06-01T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/passerine/next-steps/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/passerine/next-steps/</id>
		<content type="html">&lt;p&gt;Passerine is at an interesting point: we’ve established a few language features, and built this easily extensible functional core on which to base the rest of the language. We currently have two implementations of the language, one written in Rust, the other in D, and it’s imperative we set the course of the language before divergence occurs.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;revisiting-macros&quot;&gt;Revisiting Macros&lt;&#x2F;h1&gt;
&lt;p&gt;Currently, macros take the form:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;syntax &amp;lt;argpat&amp;gt; { &amp;lt;body&amp;gt; }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Form-based macros are very fun, as it’s easy to quickly prototype new language features. There are a few rough points though:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Macros are strictly form-based, and can’t access Passerine’s richer syntax.&lt;&#x2F;li&gt;
&lt;li&gt;Compile-time expansion of macros is fairly limited.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;At this point, macros are mostly templates. But the general idea is pretty simple: argument patterns define a finite state machine that extracts AST from forms, and these ASTs are then spliced (hygienically, I might add) into the body to produce a new AST. Here’s what that looks like:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;syntax &amp;#39;if cond then &amp;#39;else otherwise {
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;if (n &amp;lt; 2) {
&lt;&#x2F;span&gt;&lt;span&gt;    print n
&lt;&#x2F;span&gt;&lt;span&gt;} else {
&lt;&#x2F;span&gt;&lt;span&gt;    print &amp;quot;small&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is neat and all, but we can’t do things like repeating some code a variable number of times at compile time, or matching in forms to leverage existing syntax. To address the two issues I raised earlier, I think it’s time to introduce a generalized mechanism through which we can build macros in the future.&lt;&#x2F;p&gt;
&lt;p&gt;But before we do that, a quick reminder. &lt;strong&gt;Macros must respect lexical scope and hygiene&lt;&#x2F;strong&gt;. A macro defined in a function body is only accessible inside that body. It’s not possible to return a macro from a function, but it is from a module. We’ll discuss this more later.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;token-based-macros&quot;&gt;Token Based Macros&lt;&#x2F;h2&gt;
&lt;p&gt;Token based macros are powerful enough to represent the syntax-based macros we currently have in the language. The core idea is pretty simple: a macro is a function that is run at compile time: it takes a list of tokens, and produces a new list of tokens, which is then compiled.&lt;&#x2F;p&gt;
&lt;p&gt;So, what does that look like? We need a way to embed Passerine’s token stream in the language itself: for that, we’ll declare a few union types:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;type Token {
&lt;&#x2F;span&gt;&lt;span&gt;    Iden String,
&lt;&#x2F;span&gt;&lt;span&gt;    Op   String,
&lt;&#x2F;span&gt;&lt;span&gt;    Data Data,
&lt;&#x2F;span&gt;&lt;span&gt;    Group {
&lt;&#x2F;span&gt;&lt;span&gt;        delim: Delim,
&lt;&#x2F;span&gt;&lt;span&gt;        tokens: [Token],
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    Sep,
&lt;&#x2F;span&gt;&lt;span&gt;    -- and so on...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;type Delim {
&lt;&#x2F;span&gt;&lt;span&gt;    Paren,  -- ()
&lt;&#x2F;span&gt;&lt;span&gt;    Curly,  -- {}
&lt;&#x2F;span&gt;&lt;span&gt;    Square, -- []
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;-- etc...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;If you’re not familiar with union types, we’ll discuss them later on in the ADT section.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;So, for example, the variable &lt;code&gt;hello&lt;&#x2F;code&gt; would be the token &lt;code&gt;Iden &amp;quot;hello&amp;quot;&lt;&#x2F;code&gt;. The most important things to note are as follows:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Delimiters, such as parenthesis &lt;code&gt;()&lt;&#x2F;code&gt;, curly braces &lt;code&gt;{}&lt;&#x2F;code&gt;, or square brackets &lt;code&gt;[]&lt;&#x2F;code&gt; are defined via the &lt;code&gt;Group&lt;&#x2F;code&gt; variant. This means that these tokens must be balanced.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Macro transformations occur &lt;em&gt;before&lt;&#x2F;em&gt; the AST is constructed. This reduces the complexity implementation-wise, and allows for more flexible macros.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;with &lt;code&gt;Token&lt;&#x2F;code&gt; in place, let’s look at a sample token macro. These macros are denoted with the &lt;code&gt;macro&lt;&#x2F;code&gt; keyword, and take the following form:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;macro &amp;lt;keyword&amp;gt; = &amp;lt;function&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What’s important to note is that the &lt;code&gt;&amp;lt;function&amp;gt;&lt;&#x2F;code&gt; must be of type &lt;code&gt;[Token] -&amp;gt; comptime [Token]&lt;&#x2F;code&gt;. &lt;code&gt;comptime&lt;&#x2F;code&gt; is an algebraic effect representing a compile-time transformation. We’ll get into the meaning of &lt;code&gt;comptime&lt;&#x2F;code&gt; more when we discuss algebraic effects later on.&lt;&#x2F;p&gt;
&lt;p&gt;Here’s what a token macro looks like:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;-- import token variants
&lt;&#x2F;span&gt;&lt;span&gt;use Token::*
&lt;&#x2F;span&gt;&lt;span&gt;use Delim::*
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;macro while = [
&lt;&#x2F;span&gt;&lt;span&gt;    Iden &amp;quot;while&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    ..cond,
&lt;&#x2F;span&gt;&lt;span&gt;    Group {
&lt;&#x2F;span&gt;&lt;span&gt;        delim: Curly,
&lt;&#x2F;span&gt;&lt;span&gt;        tokens: body,
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;] -&amp;gt; [
&lt;&#x2F;span&gt;&lt;span&gt;    Iden &amp;quot;loop&amp;quot;, Op &amp;quot;=&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    Iden &amp;quot;_&amp;quot;, Op &amp;quot;-&amp;gt;&amp;quot; Iden &amp;quot;if&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    Group { delim: Paren, tokens: cond },
&lt;&#x2F;span&gt;&lt;span&gt;    Group { delim: Curly, tokens: ... }
&lt;&#x2F;span&gt;&lt;span&gt;    -- and so on...
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this case, we’re using pattern matching to match the incoming token stream, then immediately filling in an output token stream. It’s important to remember that a macro is just a function, so just about &lt;em&gt;any&lt;&#x2F;em&gt; strategy for writing functions can be used for writing macros.&lt;&#x2F;p&gt;
&lt;p&gt;When you think about it though, the above token macro implementing a while loop is a lot more verbose compared to its syntax equivalent:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;syntax &amp;#39;while cond body {
&lt;&#x2F;span&gt;&lt;span&gt;    loop = _ -&amp;gt; if cond {
&lt;&#x2F;span&gt;&lt;span&gt;        body
&lt;&#x2F;span&gt;&lt;span&gt;        loop ()
&lt;&#x2F;span&gt;&lt;span&gt;    } else {
&lt;&#x2F;span&gt;&lt;span&gt;        ()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    loop ()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To improve the quality-of-life of using token macros, we can write a few utilities — which are also token macros — the first of which is &lt;code&gt;quote&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;x = Data (Int 3)
&lt;&#x2F;span&gt;&lt;span&gt;tokens = quote [1, 2, splice x]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;quote&lt;&#x2F;code&gt; takes some passerine code, and expands it into a token stream, splicing in other variables using &lt;code&gt;splice&lt;&#x2F;code&gt;. For instance, the above example expands to:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;tokens == [
&lt;&#x2F;span&gt;&lt;span&gt;    Group {
&lt;&#x2F;span&gt;&lt;span&gt;        delim: Square,
&lt;&#x2F;span&gt;&lt;span&gt;        tokens: [
&lt;&#x2F;span&gt;&lt;span&gt;            Data (Int 1),
&lt;&#x2F;span&gt;&lt;span&gt;            Data (Int 2),
&lt;&#x2F;span&gt;&lt;span&gt;            Data (Int 3),
&lt;&#x2F;span&gt;&lt;span&gt;        ]
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This makes it easier to write the bodies of token macros - for instance, our incomplete while-loop body now becomes:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;... -&amp;gt; quote {
&lt;&#x2F;span&gt;&lt;span&gt;    loop = _ -&amp;gt; if (splice cond) {
&lt;&#x2F;span&gt;&lt;span&gt;        splice body
&lt;&#x2F;span&gt;&lt;span&gt;        loop ()
&lt;&#x2F;span&gt;&lt;span&gt;    } else {
&lt;&#x2F;span&gt;&lt;span&gt;        ()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    loop ()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which is a lot nicer. The second utility we can introduce is &lt;code&gt;argpat&lt;&#x2F;code&gt;, which is used for pattern matching on macros:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;argpat { &amp;#39;while cond body } = tokens
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This expands to something like this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;[Iden &amp;quot;while&amp;quot;, cond, body] = tokens
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;argpat&lt;&#x2F;code&gt; is useful because it allows us to quickly match on token streams to extract useful data. What’s important to remember is that both &lt;code&gt;quote&lt;&#x2F;code&gt; and &lt;code&gt;argpat&lt;&#x2F;code&gt; can be implemented using token macros: we’re not introducing any new syntax here.&lt;&#x2F;p&gt;
&lt;p&gt;As Passerine currently has two implementations - the &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vrtbl&#x2F;passerine&quot;&gt;Rust&lt;&#x2F;a&gt; one by me and the &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ShawSumma&#x2F;purr&#x2F;tree&#x2F;main&#x2F;ext&#x2F;passerine&quot;&gt;D&lt;&#x2F;a&gt; one by Shaw, it’s important we try to ensure compatibility between them. Token macros allow us to put language features like &lt;code&gt;syntax&lt;&#x2F;code&gt;, etc. in the prelude, resulting in less work for us, and greater compatibility between implementations.&lt;&#x2F;p&gt;
&lt;p&gt;So, if we introduce token macros, will we be getting rid of syntax macros? The answer is no: after token macros are implemented, we can implement syntax macros in terms of them.&lt;&#x2F;p&gt;
&lt;p&gt;With both &lt;code&gt;quote&lt;&#x2F;code&gt; and &lt;code&gt;argpat&lt;&#x2F;code&gt;, it’s easy to see how something like &lt;code&gt;syntax&lt;&#x2F;code&gt; can be implemented: it would be a macro that generates a macro, using &lt;code&gt;argpat&lt;&#x2F;code&gt; to match on the token stream, and quote to expand the resulting body. Some care has to be taken to ensure that names present in the argument pattern are automatically spliced; needless to say, &lt;code&gt;syntax&lt;&#x2F;code&gt; would look something like this, when implemented as a token macro:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;macro syntax = [
&lt;&#x2F;span&gt;&lt;span&gt;    Iden &amp;quot;syntax&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    ..argument_pattern
&lt;&#x2F;span&gt;&lt;span&gt;    Group {
&lt;&#x2F;span&gt;&lt;span&gt;        delim: Curly,
&lt;&#x2F;span&gt;&lt;span&gt;        tokens: body,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;] -&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    kw = extract_argpat_kw argument_pattern
&lt;&#x2F;span&gt;&lt;span&gt;    -- more omitted...
&lt;&#x2F;span&gt;&lt;span&gt;    quote {
&lt;&#x2F;span&gt;&lt;span&gt;        macro (splice kw) =
&lt;&#x2F;span&gt;&lt;span&gt;            argpat (splice argument_pattern)
&lt;&#x2F;span&gt;&lt;span&gt;        -&amp;gt; quote {
&lt;&#x2F;span&gt;&lt;span&gt;            (splice body)
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The above isn’t a concrete implementation, but should show the intended structure of the &lt;code&gt;syntax&lt;&#x2F;code&gt; macro. Remember that a token macro is just a function, so we can use any strategy imaginable to expand macros.&lt;&#x2F;p&gt;
&lt;p&gt;Now that I’ve explained how token macros work, two questions remain: how do we preserve macro hygiene, and how do we know when to apply macros?&lt;&#x2F;p&gt;
&lt;p&gt;Macro hygiene can be a complex issue, especially with respect to macro-generating macros. Even in languages known for their hygiene, like scheme, researchers have shown that there are ways to break hygiene (see, i.e. anaphoric macros). What even is macro hygiene?&lt;&#x2F;p&gt;
&lt;p&gt;Primarily, macro hygiene means that macros, when expanded, must not mess with the local lexical scope. This means that a macro can not reference variables explicitly passed to the macro. In practice, a macro can’t define new identifiers, or redefine existing ones not passed to it. For instance, assuming a small lisp-like hygienic macro system:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;; define a macro that swaps two variables
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;macro &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;swap! a b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;define tmp a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;set&lt;&#x2F;span&gt;&lt;span&gt;! a b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;set&lt;&#x2F;span&gt;&lt;span&gt;! b tmp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;; tmp is used in the macro,
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;; here, we define our own
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;define tmp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;define x   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;define y   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;; expand the macro
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;swap! x y&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;; becomes:
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;; | (define _tmp x)
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;; | (set! x y)
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;; | (set! y _tmp)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;; note that the expanded _tmp is mangled
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;; our tmp is still 1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see from the above example, even though we define &lt;code&gt;tmp&lt;&#x2F;code&gt; outside the macro &lt;code&gt;swap!&lt;&#x2F;code&gt;, because &lt;code&gt;tmp&lt;&#x2F;code&gt; is not passed to &lt;code&gt;swap!&lt;&#x2F;code&gt;, expanding the macro will not affect the outside definition. How can we enforce this at the token-stream level?&lt;&#x2F;p&gt;
&lt;p&gt;Before expanding a macro, we build a set of all &lt;code&gt;Iden&lt;&#x2F;code&gt; tokens passed to the macro. These are tokens that the macro is allowed to reference. After the macro has produced its expansion, we scan through the resulting list of tokens, and mangle any new &lt;code&gt;Iden&lt;&#x2F;code&gt;s introduced.&lt;&#x2F;p&gt;
&lt;p&gt;To ensure that mangled tokens don’t get it the way of macro expansion, all tokens are unmangled before being passed into a macro. This ensures that references to other macros within macros work as intended.&lt;&#x2F;p&gt;
&lt;p&gt;The second question we need to address is that of ‘when should macros be applied’? Traditionally, &lt;code&gt;syntax&lt;&#x2F;code&gt; macros operate on forms. For instance, consider the following expression:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;a b c + d e f
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is two forms:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;(a b c) + (d e f)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To build&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;These are my plans for macros. Next up, we’ll talk types.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;so-algebraic-data-types&quot;&gt;So, Algebraic Data Types&lt;&#x2F;h1&gt;
&lt;p&gt;Passerine primarily uses a structural type system, meaning types are represented by structure rather than by name. This works a lot of the time, but breaks down when we have two things that are structurally the same but conceptually distinct. As an example, both fractions and complex numbers can be represented as tuples of two numbers:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;my_fraction = (1, 4) -- 1&#x2F;4
&lt;&#x2F;span&gt;&lt;span&gt;my_complex  = (4, 3) -- 4+3i
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then, if we try to do something like implement a squaring number for fractions, it works on complex numbers too, which is less than ideal:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;square_fraction = (num, den)
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; (num * num, den * den)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;square my_fraction -- ok, is 1&#x2F;16
&lt;&#x2F;span&gt;&lt;span&gt;square my_complex  -- Aaaahhh! 16+9i is not correct!
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To deal with this, Passerine already has the concept of &lt;em&gt;Labels&lt;&#x2F;em&gt;. Like atoms in other languages, these currently serve as markers, i.e. loose nominal types. In other words, a &lt;em&gt;Label&lt;&#x2F;em&gt; gives us a way to separate types that would otherwise look exactly alike. With the above example in mind, using labels we get:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;my_fraction = Fraction (1, 4) -- 1&#x2F;4
&lt;&#x2F;span&gt;&lt;span&gt;my_complex  = Complex  (4, 3) -- 4+3i
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;square = Fraction (num,       den      )
&lt;&#x2F;span&gt;&lt;span&gt;      -&amp;gt; Fraction (num * num, den * den)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;square my_fraction -- ok, is 1&#x2F;16
&lt;&#x2F;span&gt;&lt;span&gt;square my_complex  -- error is raised
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is all well and good, and works well in practice. There are two downsides to labels, though:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;They can be created willy-nilly. Although compiled down to little more than integers, in the sense of ensuring correctness, they are no better than strings. If you accidentally misspell a label, it’s a different type, resulting in spurious runtime errors.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;They are strictly nominal. If your function expects a &lt;code&gt;Message (a, b)&lt;&#x2F;code&gt;, and I have my own label &lt;code&gt;Message (c, d)&lt;&#x2F;code&gt;, I could pass by &lt;code&gt;Message&lt;&#x2F;code&gt; to your function, whether or not it even means the same thing. In this case, we’re back where we started.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;To get around this, I’ve finally introduced a fully-formed notion of nominal types. Types must be declared, so a misspelling is a compile-time error; additionally, types are now &lt;em&gt;scoped&lt;&#x2F;em&gt;, so it’s possible to have two types with the same label, while still preserving uniqueness.&lt;&#x2F;p&gt;
&lt;p&gt;So how to define types? Types will follow the form of macros, in essence: &lt;code&gt;type &amp;lt;name&amp;gt; &amp;lt;definition&amp;gt;&lt;&#x2F;code&gt;. &lt;code&gt;&amp;lt;name&amp;gt;&lt;&#x2F;code&gt;, of course, is a label, and must be capitalized. &lt;code&gt;&amp;lt;definition&amp;gt;&lt;&#x2F;code&gt; looks similar to a pattern, but in place of bindings, we have types. I’ll get to what this looks like in a second.&lt;&#x2F;p&gt;
&lt;p&gt;Here’s an example type:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;type Fraction (Int, Int)
&lt;&#x2F;span&gt;&lt;span&gt;my_fraction = Fraction (1, 4)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Nothing too surprising here. We can define named struct-like types by wrapping a bare record with a label:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;type Person {
&lt;&#x2F;span&gt;&lt;span&gt;    name:  String,
&lt;&#x2F;span&gt;&lt;span&gt;    age:   Nat,
&lt;&#x2F;span&gt;&lt;span&gt;    skill: T,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, you can see we have a skill &lt;code&gt;T&lt;&#x2F;code&gt;. This is a generic parameter. All generic parameters must be single letters; for this reason, a non-generic type must be at least two letters long.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO: unions, methods (traits), etc.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;module-system&quot;&gt;Module System&lt;&#x2F;h1&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;native-over-magic&quot;&gt;Native over Magic&lt;&#x2F;h1&gt;
&lt;p&gt;Currently, to use FFI functions, we have used a hack that I’m not particularly proud of: the &lt;code&gt;magic&lt;&#x2F;code&gt; keyword. For those not familiar with it, while compiling a passerine module we can specify an FFI, which is a map from string names to Rust functions. For instance, if we have the following function in the FFI:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; bound to string &amp;quot;add_seven&amp;quot; in FFI
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;add_seven&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;data&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; Data&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Result&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Data, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        Data&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt;Real &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Ok&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;Data&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt;Real&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;7.0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;)),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;_ =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Err&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Expected a Real&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;()),
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can use it from Passerine like so:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;-- call the rust function:
&lt;&#x2F;span&gt;&lt;span&gt;magic &amp;quot;add_seven&amp;quot; 3.5
&lt;&#x2F;span&gt;&lt;span&gt;-- is 10.5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This works well enough. What I’m not a fan of is the way we select the function to run: e.g. the &lt;code&gt;magic &amp;quot;add&amp;quot;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;After some discussion with Shaw, I think that the best course of action is to remove &lt;code&gt;magic&lt;&#x2F;code&gt; in favor of a new construct, &lt;code&gt;native&lt;&#x2F;code&gt;. Like &lt;code&gt;use syntax&lt;&#x2F;code&gt;, &lt;code&gt;use native&lt;&#x2F;code&gt; is an import modifier that tells Passerine to look in the FFI for an import. Assuming the Rust &lt;code&gt;add&lt;&#x2F;code&gt; function we defined earlier is in scope:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;use native add_seven
&lt;&#x2F;span&gt;&lt;span&gt;add_seven 3.5
&lt;&#x2F;span&gt;&lt;span&gt;-- is 10.5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is nicer on a couple of fronts: native functions now act just like any other function.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;note&quot;&gt;Note&lt;&#x2F;h2&gt;
&lt;p&gt;I’m currently considering making native a module; in other words, we’d do:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;native::add_seven 3.5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;or:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;use native::add_seven
&lt;&#x2F;span&gt;&lt;span&gt;add_seven 3.5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Another line of thought is that native items should just be algebraic effects, with handlers implemented natively. We discuss algebraic effects in the next section.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;algebraic-effects&quot;&gt;Algebraic Effects&lt;&#x2F;h1&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Mirror: Hindley Milner Type Inference</title>
		<published>2021-05-01T00:00:00+00:00</published>
		<updated>2021-05-01T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/passerine/type-inference/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/passerine/type-inference/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;This is a frozen mirror of &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.cs.cornell.edu&#x2F;courses&#x2F;cs3110&#x2F;2016fa&#x2F;l&#x2F;17-inference&#x2F;notes.html&quot;&gt;notes from Cornell’s CS3110&lt;&#x2F;a&gt;. Full disclosure, I did not write this.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;topics&quot;&gt;Topics&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Type inference and reconstruction&lt;&#x2F;li&gt;
&lt;li&gt;Constraint collection&lt;&#x2F;li&gt;
&lt;li&gt;Constraint solving (unification)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;&#x2F;h2&gt;
&lt;p&gt;Java and OCaml are &lt;em&gt;statically typed&lt;&#x2F;em&gt; languages, meaning every binding has
a type that is determined at &lt;em&gt;compile time&lt;&#x2F;em&gt;—that is, before any part of
the program is executed. The type-checker is a compile-time procedure
that either accepts or rejects a program. By contrast, JavaScript and
Ruby are dynamically-typed languages; the type of a binding is not
determined ahead of time and computations like binding 42 to &lt;code&gt;x&lt;&#x2F;code&gt; and
then treating &lt;code&gt;x&lt;&#x2F;code&gt; as a string result in run-time errors.&lt;&#x2F;p&gt;
&lt;p&gt;Unlike Java, OCaml is &lt;em&gt;implicitly typed&lt;&#x2F;em&gt;, meaning programmers rarely need
to write down the types of bindings. This is often convenient,
especially with higher-order functions. (Although some people disagree
as to whether it makes code easier or harder to read). But implicit
typing in no way changes the fact that OCaml is statically typed. Rather,
the type-checker has to be more sophisticated because it must infer what
the &lt;em&gt;type annotations&lt;&#x2F;em&gt; “would have been” had the programmers written all
of them. In principle, type inference and type checking could be
separate procedures (the inferencer could figure out the types then the
checker could determine whether the program is well-typed), but in
practice they are often merged into a single procedure called
&lt;em&gt;type reconstruction&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ocaml-type-reconstruction&quot;&gt;OCaml type reconstruction&lt;&#x2F;h2&gt;
&lt;p&gt;OCaml was rather cleverly designed so that type reconstruction is a
straightforward algorithm. At a very high level, that algorithm works as
follows:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Determine the types of definitions in order, using the types of earlier
definitions to infer the types of later ones. (Which is one reason you
may not use a name before it is bound in an OCaml program.)&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;For each &lt;code&gt;let&lt;&#x2F;code&gt; definition, analyze the definition to determine
&lt;em&gt;constraints&lt;&#x2F;em&gt; about its type. For example, if the inferencer sees
&lt;code&gt;x+1&lt;&#x2F;code&gt;, it concludes that &lt;code&gt;x&lt;&#x2F;code&gt; must have type &lt;code&gt;int&lt;&#x2F;code&gt;. It gathers
similar constraints for function applications, pattern matches, etc.
Think of these constraints as a system of equations like you might
have in algebra.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Use that system of equations to solve for the type of the name
begin defined.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The OCaml type reconstruction algorithm attempts to never reject a
program that could type-check, if the programmer had written down types.
It also attempts never to accept a program that cannot possibly type
check. Some more obscure parts of the language can sometimes make type
annotations either necessary or at least helpful (see RWO chapter 22,
“Type inference”, for examples).  But for most code you write, type
annotations really are completely optional.&lt;&#x2F;p&gt;
&lt;p&gt;Since it would be verbose to keep writing “the OCaml type reconstruction
algorithm,” we’ll call the algorithm HM. That name is used throughout
the programming languages literature, because the algorithm was
independently invented by Roger &lt;u&gt;H&lt;&#x2F;u&gt;indley and Robin &lt;u&gt;M&lt;&#x2F;u&gt;ilner.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;collecting-and-solving-constraints-examples&quot;&gt;Collecting and solving constraints: Examples&lt;&#x2F;h2&gt;
&lt;p&gt;To gather the constraints for a definition, HM does the following:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Assign a preliminary type to every subexpression in the definition.
For known operations and constants, such as &lt;code&gt;+&lt;&#x2F;code&gt; and &lt;code&gt;3&lt;&#x2F;code&gt;, use the
type that is already known for it. For anything else, use a new type
variable that hasn’t been used anywhere else.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Use the “shape” of the expressions to generate constraints. For
example, if an expression involves applying a function to an
argument, then generate a constraint requiring the type of the
argument to be the same as the function’s input type.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We’ll give some examples of this first, then we’ll give the algorithms
for doing it.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;example-1&quot;&gt;Example 1.&lt;&#x2F;h4&gt;
&lt;p&gt;Here’s an example utop interaction:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;# let g x = 5 + x;;
&lt;&#x2F;span&gt;&lt;span&gt;val g : int -&amp;gt; int = &amp;lt;fun&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;How did OCaml infer the type of &lt;code&gt;g&lt;&#x2F;code&gt; here?  Let’s work it out.&lt;&#x2F;p&gt;
&lt;p&gt;First, let’s rewrite &lt;code&gt;g&lt;&#x2F;code&gt; syntactically to make our work a little easier:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;let g = fun x -&amp;gt; ((+) 5) x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We’ve made the anonymous function explicit, and we’ve made the
binary infix operator a prefix function application.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;1. Assign preliminary types.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For each subexpression of &lt;code&gt;fun x -&amp;gt; (+) 5 x&lt;&#x2F;code&gt;, including the entire
expression itself, we assign a preliminary type. We already know the
types of &lt;code&gt;(+)&lt;&#x2F;code&gt; and &lt;code&gt;5&lt;&#x2F;code&gt;, because those are baked into the language
itself, but for everything else we “play dumb” and just invent a new
type variable for it. For now we will use uppercase letters to represent
those type variables, rather than the OCaml syntax for type variables
(e.g., &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;Subexpression         Preliminary type
&lt;&#x2F;span&gt;&lt;span&gt;------------------    --------------------
&lt;&#x2F;span&gt;&lt;span&gt;fun x -&amp;gt; ((+) 5) x    R
&lt;&#x2F;span&gt;&lt;span&gt;    x                 U
&lt;&#x2F;span&gt;&lt;span&gt;         ((+) 5) x    S
&lt;&#x2F;span&gt;&lt;span&gt;         ((+) 5)      T
&lt;&#x2F;span&gt;&lt;span&gt;          (+)         int -&amp;gt; (int -&amp;gt; int)
&lt;&#x2F;span&gt;&lt;span&gt;              5       int
&lt;&#x2F;span&gt;&lt;span&gt;                 x    V
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;2. Collect constraints.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Here are some observations we could make about the “shape” of subexpressions
and some relationships among them:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Since function argument &lt;code&gt;x&lt;&#x2F;code&gt; has type &lt;code&gt;U&lt;&#x2F;code&gt; and function body &lt;code&gt;((+) 5) x&lt;&#x2F;code&gt;
has type &lt;code&gt;S&lt;&#x2F;code&gt;, it must be the case that &lt;code&gt;R&lt;&#x2F;code&gt;, the type of the anonymous
function expression, satisfies the constraint &lt;code&gt;R = U -&amp;gt; S&lt;&#x2F;code&gt;.
That is, &lt;em&gt;the type of the anonymous function&lt;&#x2F;em&gt; is &lt;em&gt;the type of its argument&lt;&#x2F;em&gt;
arrow &lt;em&gt;the type of its body&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Since function &lt;code&gt;((+) 5)&lt;&#x2F;code&gt; has type &lt;code&gt;T&lt;&#x2F;code&gt; and function
application &lt;code&gt;((+) 5) x&lt;&#x2F;code&gt; has type &lt;code&gt;S&lt;&#x2F;code&gt;, and since the argument &lt;code&gt;x&lt;&#x2F;code&gt; has
type &lt;code&gt;V&lt;&#x2F;code&gt;, it must be the case that &lt;code&gt;T = V -&amp;gt; S&lt;&#x2F;code&gt;.  That is,
&lt;em&gt;the type of the function being applied&lt;&#x2F;em&gt; is &lt;em&gt;the type of the argument it’s
being applied to&lt;&#x2F;em&gt; arrow &lt;em&gt;the type of the function application expression&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Since function &lt;code&gt;(+)&lt;&#x2F;code&gt; has type &lt;code&gt;int -&amp;gt; (int -&amp;gt; int)&lt;&#x2F;code&gt; and function
application &lt;code&gt;(+) 5&lt;&#x2F;code&gt; has type &lt;code&gt;T&lt;&#x2F;code&gt;, and since the argument &lt;code&gt;5&lt;&#x2F;code&gt;
has type &lt;code&gt;int&lt;&#x2F;code&gt;, it must be the case that &lt;code&gt;int -&amp;gt; (int-&amp;gt;int) = int -&amp;gt; T&lt;&#x2F;code&gt;.
Once again,
&lt;em&gt;the type of the function being applied&lt;&#x2F;em&gt; is &lt;em&gt;the type of the argument it’s
being applied to&lt;&#x2F;em&gt; arrow &lt;em&gt;the type of the function application expression&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Since &lt;code&gt;x&lt;&#x2F;code&gt; occurs with both type &lt;code&gt;U&lt;&#x2F;code&gt; and &lt;code&gt;V&lt;&#x2F;code&gt;, it must be the case that &lt;code&gt;U = V&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The set of constraints thus generated is:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;                  U = V
&lt;&#x2F;span&gt;&lt;span&gt;                  R = U -&amp;gt; S
&lt;&#x2F;span&gt;&lt;span&gt;                  T = V -&amp;gt; S
&lt;&#x2F;span&gt;&lt;span&gt;int -&amp;gt; (int -&amp;gt; int) = int -&amp;gt; T
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;3. Solve constraints.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;You can solve that system of equations easily. Starting from the last
constraint, we know &lt;code&gt;T&lt;&#x2F;code&gt; must be &lt;code&gt;int -&amp;gt; int&lt;&#x2F;code&gt;. Substituting that into the
second constraint, we get that &lt;code&gt;int -&amp;gt; int&lt;&#x2F;code&gt; must equal &lt;code&gt;V -&amp;gt; S&lt;&#x2F;code&gt;, hence
&lt;code&gt;V = S = int&lt;&#x2F;code&gt;. Since &lt;code&gt;U=V&lt;&#x2F;code&gt;, &lt;code&gt;U&lt;&#x2F;code&gt; must also be &lt;code&gt;int&lt;&#x2F;code&gt;. Substituting for &lt;code&gt;S&lt;&#x2F;code&gt;
and &lt;code&gt;U&lt;&#x2F;code&gt; in the first constraint, we get that &lt;code&gt;R = int -&amp;gt; int&lt;&#x2F;code&gt;. So the
inferred type of &lt;code&gt;g&lt;&#x2F;code&gt; is &lt;code&gt;int -&amp;gt; int&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;example-2&quot;&gt;Example 2.&lt;&#x2F;h4&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;# let apply f x = f x;;
&lt;&#x2F;span&gt;&lt;span&gt;val apply : (&amp;#39;a -&amp;gt; &amp;#39;b) -&amp;gt; &amp;#39;a -&amp;gt; &amp;#39;b = &amp;lt;fun&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again we rewrite:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;let apply = fun f -&amp;gt; (fun x -&amp;gt; f x)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;1. Assign preliminary types.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;Subexpression              Preliminary type
&lt;&#x2F;span&gt;&lt;span&gt;-----------------------    ------------------
&lt;&#x2F;span&gt;&lt;span&gt;fun f -&amp;gt; (fun x -&amp;gt; f x)    R
&lt;&#x2F;span&gt;&lt;span&gt;    f                      S
&lt;&#x2F;span&gt;&lt;span&gt;         (fun x -&amp;gt; f x)    T
&lt;&#x2F;span&gt;&lt;span&gt;              x            U
&lt;&#x2F;span&gt;&lt;span&gt;                   f x     V
&lt;&#x2F;span&gt;&lt;span&gt;                   f       S
&lt;&#x2F;span&gt;&lt;span&gt;                     x     U
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;2. Collect constraints.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R = S -&amp;gt; T&lt;&#x2F;code&gt;, because of the anonymous function expression.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;T = U -&amp;gt; V&lt;&#x2F;code&gt;, because of the nested anonymous function expression.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;S = U -&amp;gt; V&lt;&#x2F;code&gt;, because of the function application.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;3. Solve constraints.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Using the third constraint, and substituting for &lt;code&gt;S&lt;&#x2F;code&gt; in the first
constraint, we have that &lt;code&gt;R = (U -&amp;gt; V) -&amp;gt; T&lt;&#x2F;code&gt;.  Using the second
constraint, and substituting for &lt;code&gt;T&lt;&#x2F;code&gt; in the first constraint,
we have that &lt;code&gt;R = (U -&amp;gt; V) -&amp;gt; (U -&amp;gt; V)&lt;&#x2F;code&gt;.  There are no further
substitutions that can be made, so we’re done solving the constraints.
If we now replace the preliminary type variables with actual OCaml
type variables, specifically &lt;code&gt;U&lt;&#x2F;code&gt; with &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; and &lt;code&gt;V&lt;&#x2F;code&gt; with &lt;code&gt;&#x27;b&lt;&#x2F;code&gt;, we get that
the type of &lt;code&gt;apply&lt;&#x2F;code&gt; is &lt;code&gt;(&#x27;a -&amp;gt; &#x27;b) -&amp;gt; (&#x27;a -&amp;gt; &#x27;b)&lt;&#x2F;code&gt;, which is the same as
&lt;code&gt;(&#x27;a -&amp;gt; &#x27;b) -&amp;gt; &#x27;a -&amp;gt; &#x27;b&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;example-3&quot;&gt;Example 3.&lt;&#x2F;h4&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;# apply g 3;;
&lt;&#x2F;span&gt;&lt;span&gt;- : int = 8
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We rewrite that as &lt;code&gt;(apply g) 3&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;1. Assign preliminary types.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In this running example, the inference for &lt;code&gt;g&lt;&#x2F;code&gt; and &lt;code&gt;apply&lt;&#x2F;code&gt; has already
been done, so we can fill in their types as known, much like the type
of &lt;code&gt;+&lt;&#x2F;code&gt; is already known.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;Subexpression     Preliminary type
&lt;&#x2F;span&gt;&lt;span&gt;-------------     ------------------------------------------
&lt;&#x2F;span&gt;&lt;span&gt;(apply g) 3       R
&lt;&#x2F;span&gt;&lt;span&gt;(apply g)         S  
&lt;&#x2F;span&gt;&lt;span&gt; apply            (U -&amp;gt; V) -&amp;gt; (U -&amp;gt; V)
&lt;&#x2F;span&gt;&lt;span&gt;       g          int -&amp;gt; int
&lt;&#x2F;span&gt;&lt;span&gt;          3       int
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;2. Collect constraints.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S = int -&amp;gt; R&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;`(U -&amp;gt; V) -&amp;gt; (U -&amp;gt; V) = (int -&amp;gt; int) -&amp;gt; S&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;3. Solve constraints.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Breaking down the last constraint, we have that &lt;code&gt;U = V = int&lt;&#x2F;code&gt;, and
that &lt;code&gt;S = U -&amp;gt; V&lt;&#x2F;code&gt;, hence &lt;code&gt;S = int -&amp;gt; int&lt;&#x2F;code&gt;.  Substituting that into
the first constraint, we have that &lt;code&gt;int -&amp;gt; int = int -&amp;gt; R&lt;&#x2F;code&gt;.  Therefore
&lt;code&gt;R = int&lt;&#x2F;code&gt;, so the type of &lt;code&gt;apply g 3&lt;&#x2F;code&gt; is &lt;code&gt;int&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;example-4&quot;&gt;Example 4.&lt;&#x2F;h4&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;# apply not false;;
&lt;&#x2F;span&gt;&lt;span&gt;- : bool = true
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By essentially the same reasoning as in example 3, HM can infer that the
type of this expression is &lt;code&gt;bool&lt;&#x2F;code&gt;. This illustrates the polymorphism of
&lt;code&gt;apply&lt;&#x2F;code&gt;: because the type &lt;code&gt;(U -&amp;gt; V) -&amp;gt; (U -&amp;gt; V)&lt;&#x2F;code&gt; of
&lt;code&gt;apply&lt;&#x2F;code&gt; contains type variables, the function can be applied to any
arguments, so long as those arguments’ types can be consistently
substituted for the type variables.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;collecting-constraints-algorithm&quot;&gt;Collecting constraints: Algorithm&lt;&#x2F;h2&gt;
&lt;p&gt;We now present an algorithm that generates constraints. This algorithm
is a precise description of how constraint gathering works in the
examples we discussed above. The algorithm is not exactly what HM does,
because HM actually performs type checking at the same time as type
inference. However, the resulting types are the same, and separating
inference from checking hopefully will give you a clearer idea of how
inference itself works.&lt;&#x2F;p&gt;
&lt;p&gt;The algorithm takes as input an expression &lt;code&gt;e&lt;&#x2F;code&gt;. We’ll
assume that every function &lt;code&gt;fun x -&amp;gt; e&#x27;&lt;&#x2F;code&gt; in that expression has an
argument with a different name. (If not, our algorithm could make a
pre-pass to rename variables. This is feasible because of lexical scope.)
The output of the algorithm is a set of constraints.&lt;&#x2F;p&gt;
&lt;p&gt;The first thing the algorithm does is to assign unique preliminary
type variables, e.g. &lt;code&gt;R&lt;&#x2F;code&gt; or &lt;code&gt;S&lt;&#x2F;code&gt;,&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;one to each &lt;em&gt;defining&lt;&#x2F;em&gt; occurrence of a variable, which could be as
a function argument or a let binding, and&lt;&#x2F;li&gt;
&lt;li&gt;one to each occurrence of each subexpression of &lt;code&gt;e&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Call the type variable assigned to &lt;code&gt;x&lt;&#x2F;code&gt; in the former clause
&lt;code&gt;D(x)&lt;&#x2F;code&gt;, and call the type variable assigned to occurrence of a
subexpression &lt;code&gt;e&#x27;&lt;&#x2F;code&gt; in the latter clause &lt;code&gt;U(e&#x27;)&lt;&#x2F;code&gt;.  The names of these
are mnemonics:  &lt;code&gt;U&lt;&#x2F;code&gt; stands for the &lt;u&gt;u&lt;&#x2F;u&gt;se of an expression,
and &lt;code&gt;D&lt;&#x2F;code&gt; stands for the &lt;u&gt;d&lt;&#x2F;u&gt;efinition of a variable name.&lt;&#x2F;p&gt;
&lt;p&gt;Next, the algorithm generates the following constraints:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;For integer constants &lt;code&gt;n&lt;&#x2F;code&gt;:  &lt;code&gt;U(n) = int&lt;&#x2F;code&gt;.  This constraints follows
from the type checking rule for integers, which says that every
integer constant has type &lt;code&gt;int&lt;&#x2F;code&gt;.  Constraints for other types of
constants are generated in a similar way.&lt;&#x2F;li&gt;
&lt;li&gt;For variables &lt;code&gt;x&lt;&#x2F;code&gt;:  &lt;code&gt;D(x) = U(x)&lt;&#x2F;code&gt;.  This constraint follows from the type
checking rule for variables, which says the type of a variable use (in this case, &lt;code&gt;U(x)&lt;&#x2F;code&gt;)
must be the same as the type at which that variable was defined (here, &lt;code&gt;D(x)&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;For function application &lt;code&gt;e1 e2&lt;&#x2F;code&gt;: &lt;code&gt;U(e1) = U(e2) -&amp;gt; U(e1 e2)&lt;&#x2F;code&gt;,
as well as any constraints resulting from &lt;code&gt;e1&lt;&#x2F;code&gt; and &lt;code&gt;e2&lt;&#x2F;code&gt;.  This constraint follows
from the type checking rule for function application.&lt;&#x2F;li&gt;
&lt;li&gt;For anonymous functions &lt;code&gt;fun x -&amp;gt; e&lt;&#x2F;code&gt;: &lt;code&gt;U(fun x -&amp;gt; e) = D(x) -&amp;gt; U(e)&lt;&#x2F;code&gt;,
as well as any constraints resulting from &lt;code&gt;e&lt;&#x2F;code&gt;.  This constraint follows from the
type checking rule for anonymous functions.&lt;&#x2F;li&gt;
&lt;li&gt;For let expressions &lt;code&gt;let x=e1 in e2&lt;&#x2F;code&gt;: &lt;code&gt;D(x)=U(e1)&lt;&#x2F;code&gt;, &lt;code&gt;U(let x=e1 in e2) = U(e2)&lt;&#x2F;code&gt;,
as well as any constraints resulting from &lt;code&gt;e1&lt;&#x2F;code&gt; and &lt;code&gt;e2&lt;&#x2F;code&gt;.  This constraint follows
from the type checking rule for let expressions.&lt;&#x2F;li&gt;
&lt;li&gt;Other expression forms:  similar kinds of constraints likewise derived from the
type checking rule for the expression form.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The result is a set of constraints, which is the output of the
algorithm. It’s not too hard to implement this algorithm as a recursive
function over a tree representing the syntax of &lt;code&gt;e&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Example.&lt;&#x2F;strong&gt;
Given expression &lt;code&gt;fun x -&amp;gt; (fun y -&amp;gt; x)&lt;&#x2F;code&gt;, a type variable &lt;code&gt;R&lt;&#x2F;code&gt; is
associated with argument &lt;code&gt;x&lt;&#x2F;code&gt;, and &lt;code&gt;S&lt;&#x2F;code&gt; with argument &lt;code&gt;y&lt;&#x2F;code&gt;.  For
subexpressions, &lt;code&gt;T&lt;&#x2F;code&gt; is associated with the occurrence of &lt;code&gt;fun x -&amp;gt; (fun y -&amp;gt; x)&lt;&#x2F;code&gt;, and &lt;code&gt;X&lt;&#x2F;code&gt; with the occurrence of &lt;code&gt;(fun y -&amp;gt; x)&lt;&#x2F;code&gt;, and &lt;code&gt;Y&lt;&#x2F;code&gt; with
the occurrence of &lt;code&gt;x&lt;&#x2F;code&gt;. (Note that the names we’ve chosen for the type
variables are completely arbitrary.) The constraints generated are &lt;code&gt;T = R -&amp;gt; X&lt;&#x2F;code&gt;, and &lt;code&gt;X = S -&amp;gt; Y&lt;&#x2F;code&gt;, and &lt;code&gt;Y = R&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;solving-constraints-algorithm&quot;&gt;Solving constraints: Algorithm&lt;&#x2F;h2&gt;
&lt;p&gt;What does it mean to solve a set of constraints? To answer this
question, we define &lt;em&gt;type substitutions&lt;&#x2F;em&gt;. A type substitution is a map
from a type variable to a type. We’ll write &lt;code&gt;{t&#x2F;X}&lt;&#x2F;code&gt; for the
substitution that maps type variable &lt;code&gt;X&lt;&#x2F;code&gt; to type &lt;code&gt;t&lt;&#x2F;code&gt;. The way a
substitution &lt;code&gt;S&lt;&#x2F;code&gt; operates on a type can be defined recursively:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;S(X)        = if S = {t&#x2F;X} then t else X
&lt;&#x2F;span&gt;&lt;span&gt;S(t1 -&amp;gt; t2) = S(t1) -&amp;gt; S(t2)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A substitution &lt;code&gt;S&lt;&#x2F;code&gt; can be applied to a constraint &lt;code&gt;t = t&#x27;&lt;&#x2F;code&gt;; the result
&lt;code&gt;S(t = t&#x27;)&lt;&#x2F;code&gt; is defined to be &lt;code&gt;S(t) = S(t&#x27;)&lt;&#x2F;code&gt;. And a substitution can be
applied to a set &lt;code&gt;C&lt;&#x2F;code&gt; of constraints; the result &lt;code&gt;S(C)&lt;&#x2F;code&gt; is the result of
applying &lt;code&gt;S&lt;&#x2F;code&gt; to each of the individual constraints in &lt;code&gt;C&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Given two substitutions &lt;code&gt;S&lt;&#x2F;code&gt; and &lt;code&gt;S&#x27;&lt;&#x2F;code&gt;, we write &lt;code&gt;S;S&#x27;&lt;&#x2F;code&gt; for their
composition: &lt;code&gt;(S;S&#x27;)(t) = S&#x27;(S(t))&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;A substitution &lt;em&gt;unifies&lt;&#x2F;em&gt; a constraint &lt;code&gt;t_1 = t_2&lt;&#x2F;code&gt; if &lt;code&gt;S(t_1) = S(t_2)&lt;&#x2F;code&gt;.
A substitution &lt;code&gt;S&lt;&#x2F;code&gt; unifies a set &lt;code&gt;C&lt;&#x2F;code&gt; of constraints if &lt;code&gt;S&lt;&#x2F;code&gt; unifies every
constraint in &lt;code&gt;C&lt;&#x2F;code&gt;. For example, substitution
&lt;code&gt;S = {int-&amp;gt;int&#x2F;Y};{int&#x2F;X}&lt;&#x2F;code&gt; unifies constraint &lt;code&gt;X -&amp;gt; (X -&amp;gt; int) = int -&amp;gt; Y&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To solve a set of constraints &lt;code&gt;C&lt;&#x2F;code&gt;, we need to find a substitution that
unifies &lt;code&gt;C&lt;&#x2F;code&gt;. If there are no substitutions that unify &lt;code&gt;C&lt;&#x2F;code&gt;, where &lt;code&gt;C&lt;&#x2F;code&gt;
is the constraints generated from expression &lt;code&gt;e&lt;&#x2F;code&gt;, then &lt;code&gt;e&lt;&#x2F;code&gt; is not
typeable.&lt;&#x2F;p&gt;
&lt;p&gt;To find a substitution that unifies &lt;code&gt;C&lt;&#x2F;code&gt;, we use an algorithm
appropriately called the &lt;em&gt;unification&lt;&#x2F;em&gt; algorithm. It is defined as
follows:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;if &lt;code&gt;C&lt;&#x2F;code&gt; is the empty set, then &lt;code&gt;unify(C)&lt;&#x2F;code&gt; is the empty substitution.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;if &lt;code&gt;C&lt;&#x2F;code&gt; is the union of a constraint &lt;code&gt;t = t&#x27;&lt;&#x2F;code&gt; with other constraints &lt;code&gt;C&#x27;&lt;&#x2F;code&gt;, then
&lt;code&gt;unify(C)&lt;&#x2F;code&gt; is defined as follows, based on that constraint:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;if &lt;code&gt;t&lt;&#x2F;code&gt; and &lt;code&gt;t&#x27;&lt;&#x2F;code&gt; are both the same type variable, e.g. &lt;code&gt;X&lt;&#x2F;code&gt;,
then return &lt;code&gt;unify(C&#x27;)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;if &lt;code&gt;t = X&lt;&#x2F;code&gt; for some type variable &lt;code&gt;X&lt;&#x2F;code&gt;, and &lt;code&gt;X&lt;&#x2F;code&gt; does not occur in &lt;code&gt;t&#x27;&lt;&#x2F;code&gt;,
then let &lt;code&gt;S = {t&#x27;&#x2F;X}&lt;&#x2F;code&gt;, and return &lt;code&gt;unify(S(C&#x27;));S&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;if &lt;code&gt;t&#x27; = X&lt;&#x2F;code&gt; for some type variable &lt;code&gt;X&lt;&#x2F;code&gt;, and &lt;code&gt;X&lt;&#x2F;code&gt; does not occur in &lt;code&gt;t&lt;&#x2F;code&gt;,
then let &lt;code&gt;S = {t&#x2F;X}&lt;&#x2F;code&gt;, and return &lt;code&gt;unify(S(C&#x27;));S&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;if &lt;code&gt;t = t0 -&amp;gt; t1&lt;&#x2F;code&gt; and &lt;code&gt;t&#x27; = t&#x27;0 -&amp;gt; t&#x27;1&lt;&#x2F;code&gt;,
then let &lt;code&gt;C&#x27;&#x27;&lt;&#x2F;code&gt; be the union of &lt;code&gt;C&#x27;&lt;&#x2F;code&gt; with the constraints
&lt;code&gt;t0 = t&#x27;0&lt;&#x2F;code&gt; and &lt;code&gt;t1 = t&#x27;1&lt;&#x2F;code&gt;, and return &lt;code&gt;unify(C&#x27;&#x27;)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;if &lt;code&gt;t = t0 * t1&lt;&#x2F;code&gt; and &lt;code&gt;t&#x27; = t&#x27;0 * t&#x27;1&lt;&#x2F;code&gt;,
then let &lt;code&gt;C&#x27;&#x27;&lt;&#x2F;code&gt; be the union of &lt;code&gt;C&#x27;&lt;&#x2F;code&gt; with the constraints
&lt;code&gt;t0 = t&#x27;0&lt;&#x2F;code&gt; and &lt;code&gt;t1 = t&#x27;1&lt;&#x2F;code&gt;, and return &lt;code&gt;unify(C&#x27;&#x27;)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;if &lt;code&gt;t = (t0, ..., tn) tc&lt;&#x2F;code&gt; and &lt;code&gt;t&#x27; = (t&#x27;0, ..., t&#x27;n) tc&lt;&#x2F;code&gt; for some
type constructor &lt;code&gt;tc&lt;&#x2F;code&gt;,
then let &lt;code&gt;C&#x27;&#x27;&lt;&#x2F;code&gt; be the union of &lt;code&gt;C&#x27;&lt;&#x2F;code&gt; with the constraints
&lt;code&gt;ti = t&#x27;i&lt;&#x2F;code&gt;, and return &lt;code&gt;unify(C&#x27;&#x27;)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;otherwise, fail. There is no possible unifier.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;In the second and third subcases, the check that &lt;code&gt;X&lt;&#x2F;code&gt; should
not occur in &lt;code&gt;t&lt;&#x2F;code&gt; ensures that the algorithm doesn’t produce a cyclic
substitution—for example, &lt;code&gt;{(X -&amp;gt; X) &#x2F; X}&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;It’s possible to prove that the unification algorithm always terminates,
and that it produces a result if and only a unifier actually exists—that
is, if and only if the set of constraints has a solution. Moreover, the
solution the algorithm produces is the &lt;em&gt;most general unifier&lt;&#x2F;em&gt;, in the
sense that if &lt;code&gt;S = unify(C)&lt;&#x2F;code&gt; and &lt;code&gt;S&#x27;&lt;&#x2F;code&gt; unifies &lt;code&gt;C&lt;&#x2F;code&gt;, then there
must exist some &lt;code&gt;S&#x27;&#x27;&lt;&#x2F;code&gt; such that &lt;code&gt;S&#x27; = S;S&#x27;&#x27;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;If &lt;code&gt;R&lt;&#x2F;code&gt; is the type variable assigned to represent the type of the entire
expression &lt;code&gt;e&lt;&#x2F;code&gt;, and if &lt;code&gt;S&lt;&#x2F;code&gt; is the substitution produced by the
algorithm, then &lt;code&gt;S(R)&lt;&#x2F;code&gt; is the type inferred for &lt;code&gt;e&lt;&#x2F;code&gt; by HM type
inference. Call that type &lt;code&gt;t&lt;&#x2F;code&gt;. It’s possible to prove &lt;code&gt;t&lt;&#x2F;code&gt; is the
&lt;em&gt;principal&lt;&#x2F;em&gt; type for the expression, meaning that if &lt;code&gt;e&lt;&#x2F;code&gt; also has type
&lt;code&gt;t&#x27;&lt;&#x2F;code&gt; for any other &lt;code&gt;t&#x27;&lt;&#x2F;code&gt;, then there exists a substitution &lt;code&gt;S&lt;&#x2F;code&gt; such that
&lt;code&gt;t&#x27; = S(t)&lt;&#x2F;code&gt;. So HM actually infers the most lenient type that is possible
for any expression.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;let-expressions&quot;&gt;Let expressions&lt;&#x2F;h2&gt;
&lt;p&gt;Consider the following code:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;let double f z = f (f z) in
&lt;&#x2F;span&gt;&lt;span&gt;(double (fun x -&amp;gt; x+1) 1, double (fun x -&amp;gt; not x) false)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The inferred type for &lt;code&gt;f&lt;&#x2F;code&gt; in &lt;code&gt;double&lt;&#x2F;code&gt; would be &lt;code&gt;X -&amp;gt; X&lt;&#x2F;code&gt;. In the
algorithm we’ve described so far, the use of &lt;code&gt;double&lt;&#x2F;code&gt; in the first
component of the pair would produce the constraint &lt;code&gt;X = int&lt;&#x2F;code&gt;, and the
use of &lt;code&gt;double&lt;&#x2F;code&gt; in the definition of &lt;code&gt;b&lt;&#x2F;code&gt; would produce the constraint &lt;code&gt;X = bool&lt;&#x2F;code&gt;. Those constraints would be contradictory, causing unification
to fail!&lt;&#x2F;p&gt;
&lt;p&gt;There is a very nice solution to this called &lt;em&gt;let-polymorphism&lt;&#x2F;em&gt;, which
is what OCaml actually uses. Let-polymorphism enables a polymorphic
function bound by a &lt;code&gt;let&lt;&#x2F;code&gt; expression behave as though it has multiple
types. The essential idea is to allow each usage of a polymorphic
function to have its own instantiation of the type variables, so that
contradictions like the one above can’t happen.&lt;&#x2F;p&gt;
&lt;p&gt;We won’t cover let-polymorphism here, but you can learn more about it
in the reading given below.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;efficiency-of-hm&quot;&gt;Efficiency of HM&lt;&#x2F;h2&gt;
&lt;p&gt;HM is usually a very efficient algorithm—you’ve probably never had to
wait for the REPL to print the inferred types of your programs. In
practice, it runs in approximately linear time. But in theory, there are
some very strange programs that can cause its running-time to blow up.
(Technically, it’s DEXPTIME-complete.) For fun, try typing the following
code in utop:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;let b = true;;
&lt;&#x2F;span&gt;&lt;span&gt;let f0 = fun x -&amp;gt; x+1;;
&lt;&#x2F;span&gt;&lt;span&gt;let f = fun x -&amp;gt; if b then f0 else fun y -&amp;gt; x y;;
&lt;&#x2F;span&gt;&lt;span&gt;let f = fun x -&amp;gt; if b then f else fun y -&amp;gt; x y;;
&lt;&#x2F;span&gt;&lt;span&gt;(* keep repeating that last line *)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You’ll see the types get longer and longer, and eventually type inference
will cause a notable delay.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-history-of-hm&quot;&gt;The history of HM&lt;&#x2F;h2&gt;
&lt;p&gt;HM has been rediscovered many times by many people. Curry used it
informally in the 1950’s (perhaps even the 1930’s). He wrote it up
formally in 1967 (published 1969). Hindley discovered it independently
in 1969; Morris in 1968; and Milner in 1978. In the realm of logic,
similar ideas go back perhaps as far as Tarski in the 1920’s. Commenting
on this history, Hindley wrote,&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;There must be a moral to this story of continual re-discovery;
perhaps someone along the line should have learned to read. Or someone
else learn to write.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;Hindley–Milner type inference is one of the core algorithms that
makes the OCaml language, and many other functional languages, possible.
It is fundamentally based on traversing the source code to collect
a system of equations, then solving that system to determine the types.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;terms-and-concepts&quot;&gt;Terms and concepts&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;constraint&lt;&#x2F;li&gt;
&lt;li&gt;Hindley–Milner (HM) type inference algorithm&lt;&#x2F;li&gt;
&lt;li&gt;implicit typing&lt;&#x2F;li&gt;
&lt;li&gt;let polymorphism&lt;&#x2F;li&gt;
&lt;li&gt;preliminary type variable&lt;&#x2F;li&gt;
&lt;li&gt;static typing&lt;&#x2F;li&gt;
&lt;li&gt;substitution&lt;&#x2F;li&gt;
&lt;li&gt;type annotation&lt;&#x2F;li&gt;
&lt;li&gt;type inference&lt;&#x2F;li&gt;
&lt;li&gt;type reconstruction&lt;&#x2F;li&gt;
&lt;li&gt;unification&lt;&#x2F;li&gt;
&lt;li&gt;unifier&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;further-reading&quot;&gt;Further reading&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;newcatalog.library.cornell.edu&#x2F;catalog&#x2F;8324012&quot;&gt;&lt;em&gt;Types and Programming Languages&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, chapter 22, by Benjamin C. Pierce.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>A Small Test Post for this New Blog</title>
		<published>2021-04-30T00:00:00+00:00</published>
		<updated>2021-04-30T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/blog/first/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/blog/first/</id>
		<content type="html">&lt;h1 id=&quot;hello&quot;&gt;Hello!&lt;&#x2F;h1&gt;
&lt;p&gt;This is my first blog post.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; this is a function
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    println!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hello!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I’m debating whether to keep this up… oh well ;P&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Vaporization and Modern Memory Management</title>
		<published>2021-02-24T00:00:00+00:00</published>
		<updated>2021-02-24T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/passerine/vaporization/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/passerine/vaporization/</id>
		<content type="html">&lt;blockquote&gt;
&lt;h2 id=&quot;note&quot;&gt;Note&lt;&#x2F;h2&gt;
&lt;p&gt;This piece is a work in progress.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;An interesting design space in the field of programming language design is that of memory management. In short, programs produce data while running. This in of itself isn’t much of a problem: in fact, it’s a good thing! If your programming language doesn’t allow for the production of any useful data, you might want to take a closer look at it…&lt;&#x2F;p&gt;
&lt;p&gt;As time goes on, our program may no longer needs certain data. We could just leave this garbage floating around forever, but, alas computers a finite amount of space to work with. It’s trivial to produce useful data; the more difficult task is figuring out when it’s no longer needed.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;Originally, this work — the management of a program’s memory — was done by the programmer; older languages (like C) require memory to be explicitly &lt;code&gt;malloc&lt;&#x2F;code&gt;ed and &lt;code&gt;free&lt;&#x2F;code&gt;d.&lt;&#x2F;p&gt;
&lt;p&gt;While giving more low-level control to the programmer, the overhead of keeping track of all the lifetimes of data currently in scope is hard for a person to keep in their head, especially when slogging through some other tough, non-trivial problem.&lt;&#x2F;p&gt;
&lt;p&gt;In this post, we’ll take a journey through time and take a look at ways to manage memory. We’ll conclude by introducing Vaporization, a novel joint compile-time&#x2F;runtime memory-management strategy that guarantees two things:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Values are only alive where they are still useful.&lt;&#x2F;li&gt;
&lt;li&gt;Data will be mutated in-place wherever possible.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;But before we reach that point, it’s useful to have some background. And &lt;em&gt;oh&lt;&#x2F;em&gt; some background we will have:&lt;&#x2F;p&gt;
&lt;h2 id=&quot;manual-memory-management&quot;&gt;Manual Memory Management&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;words-and-ram-what-is-memory-anyway&quot;&gt;Words and RAM: What is memory, anyway?&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;If you’re already familiar with how memory management works, i.e. you’ve written some C or know what a pointer is, this next section will probably be very boring; just skip it.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;To better understand memory &lt;em&gt;management&lt;&#x2F;em&gt;, we first must better understand &lt;em&gt;memory&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Memory, in the broadest sense, is some hardware that data can be written to or read from. All computers ship with some amount of &lt;em&gt;Random Access Memory&lt;&#x2F;em&gt; (RAM), which is fast temporary memory used to store program state. My laptop, for instance, has a measly 4 gigabytes of RAM, whereas some higher-end desktops can ship with as much as 128GB (which I find disturbing).&lt;&#x2F;p&gt;
&lt;p&gt;RAM can be thought of as a very long list of addressed slots of the same size; on modern 64-bit computers, for instance, each slot stores 8 bytes, or 64 bits (hence the name). The number of bits a computer stores per slot is known as the &lt;em&gt;word size&lt;&#x2F;em&gt; of the machine.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;In the following text, we’ll assume a 64-bit system, which I’d say are the most common today, and will likely be the most common for years to come: although 32-bit systems can only address 2^32 = ~4GB of memory, 64-bit systems can address 16.8 million &lt;em&gt;&lt;strong&gt;terabytes&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;, which is a metric-crap-tonne of memory. (Modern architectures usually limit this to something closer to a single terabyte, which is still a &lt;em&gt;lot&lt;&#x2F;em&gt;). Anyway, on a 64-bit system:&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Each word can represent anything that can fit in that finite amount of space. These 8 bytes can represent whatever you like: an integer (from 2^-31 to 2^31), a double-precision floating-point number, or even &lt;em&gt;another&lt;&#x2F;em&gt; set of 8 bytes. You can do a lot with 8 bytes, but you can’t do everything.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;I’ll refer use slots and words interchangeably, preferably sticking to the former. Although there are some slightly differing semantics, these two definitions are close enough for our purposes.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;structs&quot;&gt;Structs&lt;&#x2F;h3&gt;
&lt;p&gt;To build data-structures larger than 8 bytes, series of slots can be reserved. In compiled programming languages, these product-typed regions of memory are known as structs. Here’s a struct representing an (x, y) coordinate pair in good-ol’ C:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;coordinate &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt; y&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A &lt;code&gt;double&lt;&#x2F;code&gt; is an IEEE double-precision floating point number — it requires 64 bits of memory. Because this struct, &lt;code&gt;coordinate&lt;&#x2F;code&gt;, has &lt;em&gt;two&lt;&#x2F;em&gt; doubles, 128 bits of memory, 16 bytes, or two slots are required to store it.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;It’s important to note that in theory, memory can be used however you’d like — In most cases, no higher-level representation is enforced by the operating system — a struct is just a convenient and reliably abstraction that we can use to talk about blocks of memory that span multiple slots, each slot (or group of slots) in that region referring to field in the struct.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Memory slots are required to be used in full, so structs are also &lt;em&gt;padded&lt;&#x2F;em&gt; to the nearest slot. For example, a C &lt;code&gt;char&lt;&#x2F;code&gt; is usually 8 bytes of memory.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;char_pair &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;char&lt;&#x2F;span&gt;&lt;span&gt; first&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;char&lt;&#x2F;span&gt;&lt;span&gt; second&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;char_number &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;char&lt;&#x2F;span&gt;&lt;span&gt; letter&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt; number&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;char_pair&lt;&#x2F;code&gt; would only take one slot to store on &amp;gt;16-bit systems, as the struct is 16 bits long. Likewise, on a 64 bit system, &lt;code&gt;char_number&lt;&#x2F;code&gt; would take 2 slots to store. Although it only uses 9 bytes of actual memory, the struct is padded to the nearest 8 bytes.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;optimization-memory-alignment&quot;&gt;Optimization: Memory Alignment&lt;&#x2F;h4&gt;
&lt;p&gt;Instead of storing values back-to-back, individual values are aligned to the nearest slot. Instead of layout out &lt;code&gt;char_number&lt;&#x2F;code&gt; like so:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;CDDDDDDD
&lt;&#x2F;span&gt;&lt;span&gt;D_______
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler tries to align number to the nearest slot:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;C_______
&lt;&#x2F;span&gt;&lt;span&gt;DDDDDDDD
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This makes is faster to access individual values, as each field is stored in its own slot and no bit-twiddling has to be done to extract the data. Data can also be aligned along cache lines for even faster access, but that’s a bit out-of-scope at the moment.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;arrays&quot;&gt;Arrays&lt;&#x2F;h3&gt;
&lt;p&gt;The primary issue with structs is that they’re static; once one is constructed, it can’t grow in size. This isn’t much of an issue for values that rely on a constant number of bits, but it is a large issue when a variable-sized collection datum needs to be kept.&lt;&#x2F;p&gt;
&lt;p&gt;To allocate multiple values, we can allocate a region of memory of a certain size. These arrays are inherently statically sized — an array can only hold the number of items it is allocated with — to store a larger number of items, the a larger array needs to be reallocated.&lt;&#x2F;p&gt;
&lt;p&gt;A dynamically sized array (a &lt;em&gt;vector&lt;&#x2F;em&gt;), common in most programming languages (such as Rust, Python, or whatever-have you), is simply a wrapper around an array that automatically reallocates it to the needed size as more values are added or removed. These allocations occur as the array grows or shrinks by an order of magnitude.&lt;&#x2F;p&gt;
&lt;img style=&quot;background-color: #fff; padding: 10px;&quot; alt=&quot;A picture describing a dynamic array.&quot; src=&quot;https:&#x2F;&#x2F;upload.wikimedia.org&#x2F;wikipedia&#x2F;commons&#x2F;thumb&#x2F;3&#x2F;31&#x2F;Dynamic_array.svg&#x2F;220px-Dynamic_array.svg.png&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;“Several values are inserted at the end of a dynamic array using geometric expansion. Grey cells indicate space reserved for expansion. Most insertions are fast (constant time), while some are slow due to the need for reallocation (Θ(n) time, labelled with turtles). The logical size and capacity of the final array are shown.”&lt;&#x2F;p&gt;
&lt;p&gt;— Wikipedia&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;pointers&quot;&gt;Pointers&lt;&#x2F;h3&gt;
&lt;p&gt;The main issue with vectors is that they can take up a variable amount of space. If you tried to cram a vector directly into a struct, for instance, the entire struct would have to be reallocated along with the array.* In this case, it’d be much easier to describe &lt;em&gt;where the array is&lt;&#x2F;em&gt; than *what it &lt;em&gt;contains&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;*Of course, this doesn’t really make much sense, which is why it’s not possible.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;As memory is simply a long series of slots, to &lt;em&gt;reference&lt;&#x2F;em&gt; another location in memory, any slot can be referenced by its index. This index, or &lt;em&gt;pointer&lt;&#x2F;em&gt;, is usually less than or equal to the slot size of the architecture.&lt;&#x2F;p&gt;
&lt;p&gt;So, for example, the structure definition of a dynamically sized vector of &lt;code&gt;double&lt;&#x2F;code&gt;s might look like so in C:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;vector &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; capacity&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; count&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt; doubles&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;*&lt;&#x2F;code&gt; in c represents a pointer to another location in memory. Because &lt;code&gt;pointer&lt;&#x2F;code&gt; and &lt;code&gt;int&lt;&#x2F;code&gt; are both usually the size of a machine word, this struct will only take up 3 slots, even if it contains millions of values.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;aside-linked-lists&quot;&gt;Aside: Linked Lists&lt;&#x2F;h4&gt;
&lt;p&gt;Pointers can reference any location in memory, including other structures. Another way to implement a growable collection of elements is to use a linked list A linked list is a structure that contains a pointer to the next node in memory:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;link &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    link &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt; item&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The above is a singly-linked list of &lt;code&gt;double&lt;&#x2F;code&gt;s. To add an item, construct a new &lt;code&gt;link&lt;&#x2F;code&gt; and update next to be the a pointer to that &lt;code&gt;link&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;tagged-unions-i-e-enums&quot;&gt;Tagged Unions, i.e. Enums&lt;&#x2F;h2&gt;
&lt;p&gt;As you know at this point, a struct is just a region of memory, where different slots correspond to different fields. It’s possible to make a struct that can represent different types of values: this sum-typed region of memory is is known as a tagged union or enumeration in most programming languages - here’s one in Rust:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span&gt;Size &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    Small &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        one&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;},
&lt;&#x2F;span&gt;&lt;span&gt;    Big &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        one&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        two&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;usize
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;},
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;For the uninitiated, in Rust a &lt;code&gt;usize&lt;&#x2F;code&gt; is an unsigned integer the size of a word. The following is mostly Rust-specific, but the concepts can be applied generally:&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;code&gt;Size&lt;&#x2F;code&gt; can be one of two structs: &lt;code&gt;Size::Small&lt;&#x2F;code&gt;, or &lt;code&gt;Size::Big&lt;&#x2F;code&gt; - each of these sub-items is known as a &lt;em&gt;variant&lt;&#x2F;em&gt;. &lt;code&gt;Small&lt;&#x2F;code&gt; contains a single &lt;code&gt;usize&lt;&#x2F;code&gt; and is therefore only one slot big, whereas &lt;code&gt;Big&lt;&#x2F;code&gt; contains two &lt;code&gt;usize&lt;&#x2F;code&gt;s, and is therefore two slots big.&lt;&#x2F;p&gt;
&lt;p&gt;How does the computer we know which struct we’re talking about, though? Given a reference to &lt;code&gt;Size&lt;&#x2F;code&gt;, how can we determine which variant it is?&lt;&#x2F;p&gt;
&lt;p&gt;The usual solution is to store a hidden field, called the variant &lt;em&gt;tag&lt;&#x2F;em&gt;, which is a number (usually a byte) that points out which variant we’re referring to. &lt;code&gt;0x00&lt;&#x2F;code&gt;, for instance, could be &lt;code&gt;Small&lt;&#x2F;code&gt;, and &lt;code&gt;0x01&lt;&#x2F;code&gt; could be &lt;code&gt;Big&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pro-tip: this is why it’s called a ‘Tagged Union’ ;).&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;An enum takes on the size of its largest variant, plus a byte for the variant, padded out to the nearest word. Following this logic, we can easily see that &lt;code&gt;Size&lt;&#x2F;code&gt; should be 3 slots large: 2 slots because of &lt;code&gt;Big&lt;&#x2F;code&gt;, 1 for of the tag (+ padding). In memory this looks something like so:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;T_______
&lt;&#x2F;span&gt;&lt;span&gt;XXXXXXXX
&lt;&#x2F;span&gt;&lt;span&gt;XXXXXXXX
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Where &lt;code&gt;T&lt;&#x2F;code&gt; is the tag, and &lt;code&gt;X&lt;&#x2F;code&gt; are either variant.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-anatomy-of-the-program&quot;&gt;The Anatomy of the Program&lt;&#x2F;h2&gt;
&lt;p&gt;After that grueling section, We’ve finally finished the appetizer and started the first course. From here on out, I assume you’re comfortable talking about memory. (Later, we’ll introduce a few new concepts, such as reference counting and Copy-on-Write pointers.)&lt;&#x2F;p&gt;
&lt;p&gt;When a program is run,&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-stack&quot;&gt;The Stack&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;the-heap&quot;&gt;The Heap&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;what-is-garbage-exactly&quot;&gt;What is Garbage, Exactly?&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;data-lifetimes&quot;&gt;Data Lifetimes&lt;&#x2F;h3&gt;
&lt;h2 id=&quot;problems-with-data&quot;&gt;Problems with Data&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;use-after-free&quot;&gt;Use-After-Free&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;dangling-pointers&quot;&gt;Dangling Pointers&lt;&#x2F;h3&gt;
&lt;h1 id=&quot;memory-management-strategies&quot;&gt;Memory Management Strategies&lt;&#x2F;h1&gt;
&lt;p&gt;At this point, we’ve covered how m&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-simple-example-reference-counting&quot;&gt;A Simple Example: Reference Counting&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;a-not-so-simple-example-cycles&quot;&gt;A Not-so-Simple Example: Cycles&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;aside-breaking-cycles&quot;&gt;Aside: Breaking Cycles&lt;&#x2F;h4&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;garbage-collection-taking-out-the-trash&quot;&gt;Garbage Collection: Taking Out the Trash&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;aside-functional-programming-and-persistent-datatypes&quot;&gt;Aside: Functional Programming and Persistent Datatypes&lt;&#x2F;h4&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;compile-time-garbage-collection&quot;&gt;Compile Time Garbage Collection&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;borrow-checking&quot;&gt;Borrow Checking&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;compile-time-paths&quot;&gt;Compile-Time Paths&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;aside-generational-arenas&quot;&gt;Aside Generational Arenas&lt;&#x2F;h4&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;vaporization&quot;&gt;Vaporization&lt;&#x2F;h2&gt;
&lt;p&gt;You’ve made it! you’re finally here! Now that we understand what memory &lt;em&gt;is&lt;&#x2F;em&gt; and how we &lt;em&gt;manage&lt;&#x2F;em&gt; it, I’m going to introduce Passerine (a novel programming language) and Vaporization.&lt;&#x2F;p&gt;
&lt;p&gt;Vaporization boils down to a set of compile-time optimizations that ensure that only useful data is accessible through the lifetime of the program, with minimum support for the language runtime. However, a runtime is still required, so Vaporization remains more suited to interpreted languages.&lt;&#x2F;p&gt;
&lt;p&gt;What’s most interesting about this, however, is that this system requires minimal interference from the compiler when used in conjunction with a VM. All the compiler has to do is annotate the last usage of the value of any variables; the rest can be done automatically and very efficiently at runtime.&lt;&#x2F;p&gt;
&lt;p&gt;Vaporization is an automatic memory management system that allows for &lt;em&gt;Functional but in Place&lt;&#x2F;em&gt; style (we’ll get to this) programming. For Vaporization to work, the compiler makes the following invariants hold:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;All functions parameters are passed by value, via Copy on Write reference (CoW).&lt;&#x2F;li&gt;
&lt;li&gt;A form of SSA is performed so that the last usage of any value is that value itself, and is not CoW reference to that value.&lt;&#x2F;li&gt;
&lt;li&gt;All values captured by closures are immutable.&lt;&#x2F;li&gt;
&lt;li&gt;All functions must return a value that is not CoW.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;We’ll work through each of these rules and various examples in the following section to build an intuition as to why Vaporization works. Afterwards, we’ll write a semi-formal proof as to why this holds, and discuss Vaporization’s tradeoffs and limitations.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;what-is-copy-on-write&quot;&gt;What is Copy on Write?&lt;&#x2F;h3&gt;
&lt;p&gt;A copy on write reference (CoW) is a pointer to some immutable data, that when written to, is copied to a new memory location first.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s develop a better intuition for how this works. Say we have a struct that looks like this. I’ll use Rust* for this example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;std&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt;borrow&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt;Cow&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Thing &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    first&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:  &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    second&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;change_first&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;thing&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;Cow&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Thing&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;value&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;usize
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; value &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; thing&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;first &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; clone thing on write
&lt;&#x2F;span&gt;&lt;span&gt;        thing&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;to_mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span&gt;first &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; value&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; make a Cow reference to a `Thing`
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; thing &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; Thing &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        first&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;420&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        second&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;69
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;Cow&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt;from&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;thing&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; 100 is less than 420, so no copy is made
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;change_first&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut ref&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; 9000 is over 420, so copy is made
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;change_first&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut ref&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;9000&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;* Rust technically calls this a ‘Clone on Write’, because ‘cloning’ (deep copy) and ‘copying’ (memory copy) have slightly different semantics. Luckily both ‘clone’ and ‘copy’ start with a ‘c’, So I’ll just be referring to the general concept as ‘CoW’.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;That was a big example, but there are basically a few things to take away:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;When we pass a &lt;code&gt;Cow&lt;&#x2F;code&gt; reference to a function, no copy of the wrapped value is made.&lt;&#x2F;li&gt;
&lt;li&gt;Only upon writing to the thing (&lt;code&gt;thing.to_mut().first = value&lt;&#x2F;code&gt;) is the copy made.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;This means that the immutable data wrapped in the &lt;code&gt;Cow&lt;&#x2F;code&gt; is safe, and can not be mutated - yet functions can mutate the &lt;em&gt;reference&lt;&#x2F;em&gt;, producing new useful values.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;passing-by-value-with-cow&quot;&gt;Passing by Value with CoW&lt;&#x2F;h3&gt;
&lt;p&gt;Passerine, unlike Rust, does not allow for pass-by-mutable-reference* (that’s what the &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; means) — instead, Passerine is completely pass by value. If we approach pass by value naïvely, it’s tempting to make a copy of every object before it’s passed to a function. However, if we have a million-element list, imagine what havoc that could wreak:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elm&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-elm &quot;&gt;&lt;code class=&quot;language-elm&quot; data-lang=&quot;elm&quot;&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;-- this is Passerine, by the way
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;-- I&amp;#39;m using this as a notation for a big list
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;-- just note that the items are elided
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;big_list &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;[ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;_ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;100 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;-- some function that just reads `big_list`
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;conswizzle big_list&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If a copy of &lt;code&gt;big_list&lt;&#x2F;code&gt; were made every time it were passed to &lt;code&gt;conswizzle&lt;&#x2F;code&gt;, 100 copies would be made! That’s no good for performance!&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;aside-pass-by-value-vs-pass-by-reference&quot;&gt;Aside: Pass by Value vs. Pass by Reference&lt;&#x2F;h4&gt;
&lt;p&gt;Pass by value means that when you pass something to a function, that function only has the value itself to work with. For example, if we have:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elm&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-elm &quot;&gt;&lt;code class=&quot;language-elm&quot; data-lang=&quot;elm&quot;&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;set_to_2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;{&lt;&#x2F;span&gt;&lt;span&gt; n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;set_to_2 &lt;&#x2F;span&gt;&lt;span&gt;x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;n = 2&lt;&#x2F;code&gt; in the function &lt;code&gt;set_to_2&lt;&#x2F;code&gt; will &lt;strong&gt;not&lt;&#x2F;strong&gt; overwrite the value of &lt;code&gt;x&lt;&#x2F;code&gt;; &lt;code&gt;x&lt;&#x2F;code&gt; is still 3. This goes for larger collections as well, such as lists or records (structs), which is not always enforced by all languages that appear to be pass by value (Python comes to mind).&lt;&#x2F;p&gt;
&lt;p&gt;In Rust, however, we can pass by value, so the following is perfectly valid (albeit not &lt;strong&gt;exactly&lt;&#x2F;strong&gt; idiomatic):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;set_to_2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;set_to_2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Luckily for us, Rust makes the fact that &lt;code&gt;x&lt;&#x2F;code&gt; may be overwritten perfectly clear, as you can see with the generous sprinkling of &lt;code&gt;mut&lt;&#x2F;code&gt; used throughout the listing. Anyway, back to not copying things with every function call:&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;So, how do we overcome unnecessarily copying values before passing them to functions? With our good friend Copy on Write, of course! Recall our earlier example: a value passed via CoW to a function is not mutated, no copy is made. So as long as &lt;code&gt;conswizzle&lt;&#x2F;code&gt; is read-only, even if it’s called thousands times, no copies will be made:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elm&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-elm &quot;&gt;&lt;code class=&quot;language-elm&quot; data-lang=&quot;elm&quot;&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;big_list &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;[ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;loop {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;-- to the moon!
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;conswizzle big_list&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But what &lt;em&gt;if&lt;&#x2F;em&gt; mutations are made? We’ve addressed invariant #1:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;All functions parameters are passed by value, via Copy on Write reference (CoW).&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Now on to #2!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;static-single-assignment-mutate-on-last-use&quot;&gt;Static Single Assignment: Mutate on Last Use&lt;&#x2F;h3&gt;
&lt;p&gt;If a function doesn’t mutate a list, it doesn’t copy it. Consider the following situation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elm&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-elm &quot;&gt;&lt;code class=&quot;language-elm&quot; data-lang=&quot;elm&quot;&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;[ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; modify_value x
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;print &lt;&#x2F;span&gt;&lt;span&gt;x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;By the way: in Passerine, mutations can be made to values in their local scope. This is not altogether that dissimilar from a let-style redefinition, for those familiar.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;So, just looking at this listing, it’s apparent that &lt;code&gt;modify_value&lt;&#x2F;code&gt; modifies &lt;code&gt;x&lt;&#x2F;code&gt;! Because &lt;code&gt;[ ... ]&lt;&#x2F;code&gt; will be passed as a CoW reference to &lt;code&gt;modify_value&lt;&#x2F;code&gt;, a copy of the list will be made, right?&lt;&#x2F;p&gt;
&lt;p&gt;Wrong. Let’s reintroduce Vaporization’s rule #2:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A form of SSA is performed so that the last usage of any value is that value itself, and is not CoW reference to that value.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;SSA? What’s that? and how does it help?&lt;&#x2F;p&gt;
&lt;p&gt;Single Static Assignment (SSA) is a family of optimizations that have existed in compilers for about forever. It basically boils down to marking mutations to variables as separate variables. So, if we use a subscript notation to represent that a variable by the same name holds a different value, the above listing now looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elm&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-elm &quot;&gt;&lt;code class=&quot;language-elm&quot; data-lang=&quot;elm&quot;&gt;&lt;span&gt;x₀ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;[ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;x₁ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; modify_value x₀
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;print &lt;&#x2F;span&gt;&lt;span&gt;x₁
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Ok, so that’s the first part of SSA. What about the second part? Let’s annotate the last usage of each variable in the scope - we’ll do this by appending (&lt;code&gt;&#x27;&lt;&#x2F;code&gt;) to the last occurrence:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elm&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-elm &quot;&gt;&lt;code class=&quot;language-elm&quot; data-lang=&quot;elm&quot;&gt;&lt;span&gt;x₀ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;[ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;x₁ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; modify_value x₀&amp;#39;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;print &lt;&#x2F;span&gt;&lt;span&gt;x₁&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;At this point, I can see some of you smiling smugly in the back of the class.&lt;&#x2F;p&gt;
&lt;p&gt;Notice that the last occurrence of &lt;code&gt;x₀&#x27;&lt;&#x2F;code&gt; is passed to &lt;code&gt;modify_value&lt;&#x2F;code&gt;. After this point in time, by definition it is &lt;em&gt;impossible&lt;&#x2F;em&gt; for the program to reference the value of &lt;code&gt;x₀&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Because this is the last usage of &lt;code&gt;x₀&lt;&#x2F;code&gt;, it doesn’t matter if we mutate it, etc. — which means, we can pass the value of &lt;code&gt;x₀&lt;&#x2F;code&gt; to &lt;code&gt;modify_value&lt;&#x2F;code&gt; without wrapping it in a CoW reference first. Then, when &lt;code&gt;modify_value&lt;&#x2F;code&gt; modifies the unwrapped value, it will mutate &lt;code&gt;x&lt;&#x2F;code&gt; in place without making a copy.&lt;&#x2F;p&gt;
&lt;p&gt;I’ll reiterate this: the last usage of a value is always the value itself, so mutations to that value &lt;strong&gt;do not copy it&lt;&#x2F;strong&gt;. This means that from &lt;code&gt;x = [ ... ]&lt;&#x2F;code&gt; to &lt;code&gt;print x&lt;&#x2F;code&gt;, no copies of the big list are made! This is the foundation of functional-but-in-place programming. Even though we write our code in a functional pipelined manner, all modifications to the data will occur in-place.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;returning-by-value&quot;&gt;Returning by Value&lt;&#x2F;h3&gt;
&lt;p&gt;Only one reference.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;closures-capture&quot;&gt;Closures Capture&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;aside-a-cyclic-problem&quot;&gt;Aside: A Cyclic Problem&lt;&#x2F;h4&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;why-closures-must-be-immutable&quot;&gt;Why Closures Must be Immutable&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;aside-optimizing-this-away&quot;&gt;Aside: Optimizing this away&lt;&#x2F;h4&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;TODO: stack charts and pull reference from comments on HN&lt;&#x2F;p&gt;
&lt;h3 id=&quot;functional-but-in-place-fbip&quot;&gt;Functional, but in Place (FBIP)&lt;&#x2F;h3&gt;
&lt;p&gt;As far as I’m aware, this phrase originates from Koka, a programming language that focuses on algebraic effect handlers. Although Passerine doesn’t use the same automatic memory management strategy as Koka (which is called Perceus, btw), the same idea stands. From the Koka website:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;With Perceus reuse analysis, we can write algorithms that dynamically adapt to use in-place mutation when possible (and use copying when used persistently). […] This style of programming leads to a new paradigm that we call FBIP: “functional but in place”. Just like tail-call optimization lets us describe loops in terms of regular function calls, reuse analysis lets us describe in-place mutating imperative algorithms in a purely functional way (and get persistence as well).&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;TODO: more&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tradeoffs-and-limitations&quot;&gt;Tradeoffs and Limitations&lt;&#x2F;h3&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>FFIs [Were] Hard</title>
		<published>2020-12-12T00:00:00+00:00</published>
		<updated>2020-12-12T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/passerine/ffi-hard/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/passerine/ffi-hard/</id>
		<content type="html">&lt;blockquote&gt;
&lt;h2 id=&quot;note&quot;&gt;Note&lt;&#x2F;h2&gt;
&lt;p&gt;This post was written early on in Passerine’s development, before we had an FFI to interact with Rust. The FFI is still not fully finalized; most notably, as of writing this header, we need to still implement serde-style macros to easily interface with Rust datatypes, implement a module system to allow for external modules, and (eventually) allow for FFI interaction w&#x2F; Wasm modules for cross-platform FFI support.&lt;&#x2F;p&gt;
&lt;p&gt;It’s possible to add two numbers in Passerine now, don’t worry ;D&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;or-why-you-can-t-even-add-two-numbers-in-passerine-yet&quot;&gt;Or, why you can’t even add two numbers in Passerine yet.&lt;&#x2F;h2&gt;
&lt;p&gt;I figure someone will ask this question eventually, so I’m writing this response now. Foreign Functional Interfaces are hard. Not conceptually speaking — I could probably crank (an admittedly bad one) out in an afternoon — but in terms of designing a solution with an active admonition of traits Passerine strives to embody.&lt;&#x2F;p&gt;
&lt;p&gt;Above all else, Passerine strives to be a &lt;em&gt;concise&lt;&#x2F;em&gt; language, in terms of design and implementation. What does this mean? I mean concision on two fronts:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The language and it’s implementation should be simple. You should be able to keep the entire system in your head, and understand how everything fits together.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;The language and it’s implementation should be combinatorial. Although the language should be simple, it should feel as friction-less as possible. The answer to “Wait, can A and B work together like this?” should always be “Woah, I wasn’t expecting that to work, but it makes so much sense”&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;These goals are slightly conflicting. To build a system where everything composes together perfectly requires Good Architecture™ to be in place. Essentially, &lt;code&gt;MxN&lt;&#x2F;code&gt; problems need to be reduced to &lt;code&gt;Mx1, 1xN&lt;&#x2F;code&gt; problems wherever possible.&lt;&#x2F;p&gt;
&lt;p&gt;So right, back to Passerine. Why can’t you add you numbers yet?&lt;&#x2F;p&gt;
&lt;p&gt;Adding, like any other operation, is a function. There’s nothing too special about adding when compared to subtraction, multiplication, etc. – two operands in, one value out.&lt;&#x2F;p&gt;
&lt;p&gt;What’s my point? To simplify Passerine on the two fronts mentioned above, I’m opting to build an extensible FFI system into Passerine, through which I’ll implement performance critical parts of the standard library as well as common operations on data. Instead of defining an add operator in the language itself (which dispatches on type to perform the correct operation) Passerine will simply use FFI bindings to do this.&lt;&#x2F;p&gt;
&lt;p&gt;It’s critical that this FFI be fast, which is why it’ll bind to Rust, and be compiled against the language core. In the future, I hope that something like this is possible:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; &#x2F;ffi&#x2F;thing.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;passerine&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;::{&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ff5370;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; Data&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; Runtime&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;#[&lt;&#x2F;span&gt;&lt;span&gt;passerine::bind&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c792ea;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;some_ffi_fn&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;data&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; Data&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffcb6b;&quot;&gt;Result&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Data, Runtime&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;elm&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-elm &quot;&gt;&lt;code class=&quot;language-elm&quot; data-lang=&quot;elm&quot;&gt;&lt;span style=&quot;font-style:italic;color:#4a4a4a;&quot;&gt;-- &#x2F;src&#x2F;main.pn
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;extern thing&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;some_ffi_fn
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;print &lt;&#x2F;span&gt;&lt;span&gt;some_ffi_fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c3e88d;&quot;&gt;Hello, World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;27.5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c792ea;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is great because it allows for two things:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;New operations can be quickly added to passerine. It’ll be literally updating the lexer and parser, then writing a few lines of Rust&lt;&#x2F;li&gt;
&lt;li&gt;This FFI will allows users to define their &lt;em&gt;own&lt;&#x2F;em&gt; Rust functions that can be called from Passerine allowing for easier integration with existing Rust libraries.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Of course, before this is possible, a few things need to be done:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;I need to flesh out pattern matching and the type system. This is what I’m working on now.&lt;&#x2F;li&gt;
&lt;li&gt;I need to start working on fibers, and concurrency in Passerine’s primary runtime environment, Aspen&lt;&#x2F;li&gt;
&lt;li&gt;I need to implement a module system, so using scoped FFI functions feels like using yet another Passerine module&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Of course, there are a few quality-of-life things I need to organize before I get started with this:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;People have shown interest in trying out, developing, and contributing to Passerine. Up until this point, it’s been a one-man team, so I need to figure out how to more actively engage the community towards building something rather than just asking for feedback from time to time.&lt;&#x2F;li&gt;
&lt;li&gt;There is little tooling for Passerine. I’ve tossed together a bare-bones syntax highlighter I’m too embarrassed to publish, but I hope to polish it up and get it out the door soon.&lt;&#x2F;li&gt;
&lt;li&gt;Although I’ve had a lot of free time due to COVID-19 (the largest driver of Passerine’s development by far, ironically), I still have to attend classes, do homework, and fulfill other commitments I’ve made.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I appreciate the interest. As always, if you have any questions, comments, or suggestions, you know where to find me!&lt;&#x2F;p&gt;
&lt;p&gt;Have a nice one y’all,&lt;br &#x2F;&gt;
Isaac Clayton&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>All You Need are Coroutines and Pattern Matching</title>
		<published>2020-07-10T00:00:00+00:00</published>
		<updated>2020-07-10T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/passerine/all-you-need/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/passerine/all-you-need/</id>
		<content type="html">&lt;blockquote&gt;
&lt;h2 id=&quot;note&quot;&gt;Note&lt;&#x2F;h2&gt;
&lt;p&gt;This is an old post I wrote a while back. My opinions on the subject have changed slightly but this post has historical merit. The date is not entirely accurate, this article coincides with around the time I started seriously implementing Passerine.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;&#x2F;h2&gt;
&lt;p&gt;The average programmer just wants to write code [citation needed]. Language designers, on the other hand, want to &lt;em&gt;write&lt;&#x2F;em&gt; code, that is, programming languages. Ever since the first lisp interpreter sputtered through it’s first s-exp, there’s been a quest to build a ‘perfect’ programming language. The field of language design remains open, at least in the sense that a better language can always be built. &lt;strong&gt;No matter how hard you try, there is no language that won’t make you clarify your ideas.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;In this work we present a language that can be bootstrapped from coroutines and mono-variadic lambdas, with types defined by structure rather than by name. Additionally, we show how a simple safe-yet-rich macro system can be built to leverage code clarity and convenience.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;This document predates &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vrtbl&#x2F;passerine&quot;&gt;Passerine&lt;&#x2F;a&gt;, which is an attempt to build a language based on the concepts discussed in this document.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;what-is-a-coroutine&quot;&gt;What is a Coroutine?&lt;&#x2F;h2&gt;
&lt;p&gt;Many may already be familiar with coroutines. In essence, a coroutine is a function call executed in a separate light-weight self-contained process that can pass data back-and-forth with the process that called it.&lt;&#x2F;p&gt;
&lt;p&gt;Although there is much more to be said on this topic, this basic definition is all that’s needed to understand the work laid out in this document.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pattern-matching&quot;&gt;Pattern Matching&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;Pattern Matching&lt;&#x2F;em&gt; is the action of &lt;em&gt;matching&lt;&#x2F;em&gt; a data-structure against a &lt;em&gt;pattern&lt;&#x2F;em&gt; to extract specific data. Most of the time, a pattern can be thought of as a mirror version of the data-structure that data is being extracted from. For example, the pattern:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;(x, y)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;would successfully match against the data-structure:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;(1, (2, 3))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and produce the bindings:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;x = 1
&lt;&#x2F;span&gt;&lt;span&gt;y = (2, 3)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Additionally, patterns can have &lt;em&gt;guards&lt;&#x2F;em&gt; which check that the data extracted from the data is valid. Guards should be read as &lt;em&gt;where&lt;&#x2F;em&gt; in most cases; for example, the pattern:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;x | x &amp;gt; 0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Will match any value &lt;code&gt;x&lt;&#x2F;code&gt; where &lt;code&gt;x&lt;&#x2F;code&gt; is greater than &lt;code&gt;0&lt;&#x2F;code&gt;. If a pattern match fails, due to poorly structured data or a failed guard check, an error will be returned.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-few-more-things&quot;&gt;A Few More Things&lt;&#x2F;h2&gt;
&lt;p&gt;Pattern matching is useless unless the extracted data can be used. A &lt;em&gt;lambda&lt;&#x2F;em&gt; matches a pattern and maps the bindings to a new &lt;em&gt;environment&lt;&#x2F;em&gt;. This environment is used to run the lambda’s &lt;em&gt;expression&lt;&#x2F;em&gt; in a new coroutine. A lambda is defined in the following manner:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;pattern&amp;gt; -&amp;gt; &amp;lt;expression&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and is called with the form:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;lambda&amp;gt; &amp;lt;expression&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Each lambda takes only one argument, and can yield or return at most one item. Luckily, through the use of algebraic datatypes (&lt;em&gt;tuples&lt;&#x2F;em&gt;, etc.) and pattern matching, this is not much of a problem.&lt;&#x2F;p&gt;
&lt;p&gt;Here’s an example definition and call:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;(num -&amp;gt; num + num) 7
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This function doubles the passed value - the above expression would evaluate to &lt;code&gt;14&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;By design, lambdas are &lt;em&gt;anonymous&lt;&#x2F;em&gt;. To attach a name to a value (as lambdas are values), &lt;em&gt;assignment&lt;&#x2F;em&gt; is used. Assignment is similar to a lambda expression, in the sense that it matches a pattern and binds variables. However, rather than creating the bindings in a new environment, the bound values become available in the current scope. Here’s an assignment:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;pattern&amp;gt; = &amp;lt;expression&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let’s create a named lambda, that &lt;code&gt;decrement&lt;&#x2F;code&gt;s a number by 1:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;decrement = x -&amp;gt; x - 1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And calling it on &lt;code&gt;13&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;decrement 13
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Would give us &lt;code&gt;12&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;If a lambda needs to evaluate some list of operations in sequence, a &lt;em&gt;block&lt;&#x2F;em&gt; is used. A block is a list of expressions delimited between curly braces separated by semicolons or newlines. A block may also contain a &lt;code&gt;return&lt;&#x2F;code&gt; expression, which stops the current coroutine and immediately returns a value. Otherwise, the value of the last evaluated expression in the block is returned.&lt;&#x2F;p&gt;
&lt;p&gt;Here is a function that models a linear correlation:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;linear = (m, x, b) -&amp;gt; {    
&lt;&#x2F;span&gt;&lt;span&gt;    proportional = m * x    
&lt;&#x2F;span&gt;&lt;span&gt;    return proportional + b    
&lt;&#x2F;span&gt;&lt;span&gt;    -- alternatively, omit `return`    
&lt;&#x2F;span&gt;&lt;span&gt;    -- as this is the last statement in the block
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In practice, this could be a one-liner; this is a merely a trivial example used to demonstrate the semantics of the construct.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conditionals&quot;&gt;Conditionals&lt;&#x2F;h2&gt;
&lt;p&gt;An if-expression is a feature common in many languages - our language doesn’t even have those yet. To get started with conditionals, we’ll build simplified version of an if-expression: if a condition is truthy, an expression is evaluated; otherwise, do nothing. Here’s a short example:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;if true {    
&lt;&#x2F;span&gt;&lt;span&gt;    1 + 1
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this case, &lt;code&gt;if&lt;&#x2F;code&gt; would evaluate to &lt;code&gt;2&lt;&#x2F;code&gt;. We’re going to implement &lt;code&gt;if&lt;&#x2F;code&gt; first as a lambda, and then as a &lt;em&gt;macro&lt;&#x2F;em&gt;. There is some syntactic sugar at play in the above example, which will become clear shortly. Anyway, the lambda version of &lt;code&gt;if&lt;&#x2F;code&gt; will take a tuple of two arguments:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;An expression which might be truthy.&lt;&#x2F;li&gt;
&lt;li&gt;A lambda that takes no arguments.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We’ll call the unsugared lambda definition of &lt;code&gt;if&lt;&#x2F;code&gt; ‘&lt;code&gt;iffer&lt;&#x2F;code&gt;’. Here’s how &lt;code&gt;iffer&lt;&#x2F;code&gt; would be used. This example has the same semantics as the previous &lt;code&gt;if&lt;&#x2F;code&gt; expression.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;iffer (true, () -&amp;gt; {1 + 1})
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Before we write the definition of &lt;code&gt;iffer&lt;&#x2F;code&gt;, we need to deepen out understanding of how coroutines work in our language.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s start by discussing &lt;em&gt;yielding&lt;&#x2F;em&gt;. The &lt;code&gt;yield&lt;&#x2F;code&gt; expression, when called inside a coroutine, suspends the current coroutine and returns some value. When the suspended coroutine is again, the &lt;code&gt;yield&lt;&#x2F;code&gt; function evaluates to those values, and continues running. For example, consider:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;foo = () -&amp;gt; {    
&lt;&#x2F;span&gt;&lt;span&gt;    print &amp;quot;Start&amp;quot;    
&lt;&#x2F;span&gt;&lt;span&gt;    x = yield &amp;quot;Yielding&amp;quot;    
&lt;&#x2F;span&gt;&lt;span&gt;    print x    
&lt;&#x2F;span&gt;&lt;span&gt;    print &amp;quot;End&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;x = foo ()
&lt;&#x2F;span&gt;&lt;span&gt;-- prints &amp;quot;Start&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;print (x &amp;quot;Resume&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;-- prints &amp;quot;Resume&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;-- prints &amp;quot;End&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;-- prints &amp;quot;Yielding&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;Yielding&amp;quot;&lt;&#x2F;code&gt; is printed last because &lt;code&gt;yield &amp;quot;Yielding&amp;quot;&lt;&#x2F;code&gt; sets the value of the call &lt;code&gt;(x &amp;quot;Resume&amp;quot;)&lt;&#x2F;code&gt; to &lt;code&gt;&amp;quot;Yielding&amp;quot;&lt;&#x2F;code&gt;, which is only printed after the coroutine finishes.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s talk and &lt;em&gt;trying&lt;&#x2F;em&gt; and &lt;em&gt;erring&lt;&#x2F;em&gt;. &lt;code&gt;try&lt;&#x2F;code&gt; will evaluate a coroutine; if the coroutine fails, try will return the error as a value. If the coroutine succeeds its value will be returned as normal. With this in mind, here is a naive implementation of &lt;code&gt;iffer&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;iffer = (condition, then) -&amp;gt; {    
&lt;&#x2F;span&gt;&lt;span&gt;    do_or_fail = c | c is not false -&amp;gt; then ()    
&lt;&#x2F;span&gt;&lt;span&gt;    try (do_or_fail condition)    
&lt;&#x2F;span&gt;&lt;span&gt;    return ()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here’s the break-down. As mentioned before, &lt;code&gt;iffer&lt;&#x2F;code&gt; is a function that takes two arguments. &lt;code&gt;do_or_fail&lt;&#x2F;code&gt; will only execute &lt;code&gt;then&lt;&#x2F;code&gt; if &lt;code&gt;c&lt;&#x2F;code&gt; is not falsy, because trying to evaluate &lt;code&gt;do_or_fail&lt;&#x2F;code&gt; where &lt;code&gt;c&lt;&#x2F;code&gt; is false will throw an error, which is caught by &lt;code&gt;try&lt;&#x2F;code&gt;. Finally, we return an empty tuple (aka &lt;em&gt;unit&lt;&#x2F;em&gt;), indicating that the function doesn’t produce a value.&lt;&#x2F;p&gt;
&lt;p&gt;Great! Now that we have the definition for &lt;code&gt;iffer&lt;&#x2F;code&gt;, let’s write the macro &lt;code&gt;if&lt;&#x2F;code&gt;. &lt;code&gt;if&lt;&#x2F;code&gt; transforms an &lt;code&gt;if&lt;&#x2F;code&gt; expression into an &lt;code&gt;iffer&lt;&#x2F;code&gt; function call:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;if = cond do ~&amp;gt; iffer (cond, () -&amp;gt; do)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Macros are made using a squiggly-arrow, &lt;code&gt;~&amp;gt;&lt;&#x2F;code&gt;. The arguments aren’t a pattern, they actually follow a small expressive templating language, which we’ll delve into deeper later. Anyway, the only thing we really do in this macro is hide the fact that the body after the if is actually a nullary function.&lt;&#x2F;p&gt;
&lt;p&gt;For now, let’s see this &lt;code&gt;if&lt;&#x2F;code&gt; in action:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;coroutines = &amp;quot;cool&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;if (coroutines == &amp;quot;cool&amp;quot;) {    
&lt;&#x2F;span&gt;&lt;span&gt;    print &amp;quot;Heck yeah!&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Obviously, &lt;code&gt;&amp;quot;Heck yeah!&amp;quot;&lt;&#x2F;code&gt; would be printed in this case.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;loops-and-generators&quot;&gt;Loops and Generators&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;To do.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;building-a-match-statement&quot;&gt;Building a Match Statement&lt;&#x2F;h2&gt;
&lt;p&gt;In many languages, such thing as a match statement exists.This statement matches a value against a variety of patterns, and returns the value of the first one it matches.&lt;&#x2F;p&gt;
&lt;p&gt;This might look something like:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;match x {    
&lt;&#x2F;span&gt;&lt;span&gt;    true  -&amp;gt; 1    
&lt;&#x2F;span&gt;&lt;span&gt;    false -&amp;gt; 0
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We’re going to implement match first as a function, and then as a macro. the function will take a tuple of two arguments:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;the value we want to match&lt;&#x2F;li&gt;
&lt;li&gt;and a list of lambdas that can be matched against&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;So, the above will be written as:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;matcher (x, [true -&amp;gt; 1, false -&amp;gt; 0])
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We’re using the name &lt;code&gt;matcher&lt;&#x2F;code&gt; for this function to avoid confusion with the match macro we’ll implement later on. Here’s how we might start a naive definition for matcher:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;matcher = (value, mappings) -&amp;gt; {    
&lt;&#x2F;span&gt;&lt;span&gt;    for value in mappings {        
&lt;&#x2F;span&gt;&lt;span&gt;        result = try (mappings value)        
&lt;&#x2F;span&gt;&lt;span&gt;        if result is not Error {            
&lt;&#x2F;span&gt;&lt;span&gt;            return result        
&lt;&#x2F;span&gt;&lt;span&gt;        }   
&lt;&#x2F;span&gt;&lt;span&gt;    }    
&lt;&#x2F;span&gt;&lt;span&gt;    error &amp;quot;Nothing was matched!&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;To-do: Summary and closing thoughts&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Architecting Asynchronous Schedulers</title>
		<published>2020-07-10T00:00:00+00:00</published>
		<updated>2020-07-10T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/passerine/schedule/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/passerine/schedule/</id>
		<content type="html">&lt;h1 id=&quot;note&quot;&gt;Note&lt;&#x2F;h1&gt;
&lt;p&gt;This post explores one design methodology for asynchronous schedulers in the context of a language that is maximally asynchronous, &lt;em&gt;i.e.&lt;&#x2F;em&gt; everything is executed asynchronously. This post is largely a reflection of trying to grapple with &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;tokio.rs&#x2F;blog&#x2F;2019-10-scheduler&#x2F;&quot;&gt;this blog post about Tokio’s scheduler&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;another-note&quot;&gt;Another Note&lt;&#x2F;h2&gt;
&lt;p&gt;This document was written around the time I started formulating Passerine. The general goal of this post, with respect to Passerine (that still exists fwiw), is to implement such a scheduler in &lt;code&gt;aspen&lt;&#x2F;code&gt; and use FFI hooks to automatically schedule the execution of passerine programs in an asynchronous &#x2F; parallel though effectually temporally correct manner.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h1&gt;
&lt;p&gt;As we approach &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rodneybrooks.com&#x2F;the-end-of-moores-law&#x2F;&quot;&gt;the end of Moore’s law&lt;&#x2F;a&gt;, we can no longer rely on increased processor speed to increase the performance of our software. In recent years, computers are being shipped with more CPUs Cores and Memory, but naïve single-threaded applications do not take advantage of this.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Asynchronous programming&lt;&#x2F;em&gt; has been becoming popular, but faces a &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2015&#x2F;02&#x2F;01&#x2F;what-color-is-your-function&#x2F;&quot;&gt;few core issues in terms of design&lt;&#x2F;a&gt;. Although &lt;em&gt;futures&lt;&#x2F;em&gt; have made some headway in recent years towards resolving this issue, the small overhead of writing asynchronous code prevents many from doing so in practice.&lt;&#x2F;p&gt;
&lt;p&gt;In a perfect world, programs would be maximally parallel, using &lt;em&gt;dataflow analysis&lt;&#x2F;em&gt; at compile time to determine which operations can be done in parallel. The main issue with this, however, is that compile-time dataflow analysis is expensive, requiring &lt;code&gt;O(n²)&lt;&#x2F;code&gt; time. In this post, we’ll explore the architecture of what automatic runtime parallelism may look like.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;everything-is-asynchronous&quot;&gt;Everything is Asynchronous&lt;&#x2F;h1&gt;
&lt;p&gt;When writing asynchronous code, it is common to use the &lt;em&gt;async&#x2F;await syntax&lt;&#x2F;em&gt; to denote asynchronous functions. The issue with this is that &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Async&#x2F;await#Benefits_and_criticisms&quot;&gt;asynchronous code is contagious&lt;&#x2F;a&gt; — any function calling asynchronous code must be declared &lt;code&gt;async&lt;&#x2F;code&gt;, and asynchronous function calls must be &lt;code&gt;await&lt;&#x2F;code&gt;ed. On the other hand, async&#x2F;await allows for asynchronous code to be written in the same manner as traditional code; in the case the no parallelism is possible, async&#x2F;await-ed code won’t take much longer than its single-threaded counterpart.&lt;&#x2F;p&gt;
&lt;p&gt;The only downside to fully asynchronous code is the overhead of scheduling the execution of said code. However, as we’ll soon see, it’s possible to design asynchronous execution schemes with minimal overhead.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;designing-a-scheduler&quot;&gt;Designing a Scheduler&lt;&#x2F;h1&gt;
&lt;p&gt;When an asynchronous function is called, it does not immediately execute; rather, it immediately returns a &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Futures_and_promises&quot;&gt;future&lt;&#x2F;a&gt;, which is a &lt;em&gt;promise to evaluate to a value in the future&lt;&#x2F;em&gt;, and is scheduled for execution.&lt;&#x2F;p&gt;
&lt;p&gt;To evaluate an awaited future, all values the future depends upon must be known. A future whose arguments are resolved is &lt;em&gt;calculable&lt;&#x2F;em&gt;, or ‘ready’, and one whose arguments are unresolved is &lt;em&gt;incalculable&lt;&#x2F;em&gt;, and hence ‘waiting’ for it’s arguments to resolve.&lt;&#x2F;p&gt;
&lt;p&gt;A &lt;em&gt;process&lt;&#x2F;em&gt; takes a ready future and resolves it, possibly creating more futures while doing so. Processes are also non-blocking, meaning that they do not depend on the futures they create to terminate to finish executing the current future.&lt;&#x2F;p&gt;
&lt;p&gt;A &lt;em&gt;scheduler&lt;&#x2F;em&gt; manages futures and distributes ready futures (we’ll call them tasks from now) to processes for execution. Naïvely, a simple scheduler might maintain a simple global queue of futures and distribute tasks to processes for resolution.&lt;&#x2F;p&gt;
&lt;p&gt;There are a few issues with a global queue — primarily, expensive synchronization between processes is required to keep the queue in a valid state. Luckily for us, there has been much research surrounding scheduler design. A good scheduler should do the following:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Maintain task locality&lt;&#x2F;li&gt;
&lt;li&gt;Limit synchronization between processes&lt;&#x2F;li&gt;
&lt;li&gt;Evenly distribute tasks among processes&lt;&#x2F;li&gt;
&lt;li&gt;Not waste time searching for ready tasks.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;maintaining-task-locality&quot;&gt;Maintaining Task Locality&lt;&#x2F;h2&gt;
&lt;p&gt;Processes working on a task should complete sub-tasks related to the task they’re working on. This speeds up the execution of tasks as they will not have to be sent between processes, and processes will not have to wait for others to finish tasks they may depend on.&lt;&#x2F;p&gt;
&lt;p&gt;So how does a scheduler maintain task locality? The general consensus seems to be giving each task its own queue rather than synchronizing a global queue. Whenever a process spawns a new future, it adds it to its own queue, and when a process needs a new task, it pulls from the queue of tasks it has accumulated.&lt;&#x2F;p&gt;
&lt;p&gt;A process with its own queue may limit cross-process synchronization, but it does not ensure the workload is evenly distributed. One process could accumulate a large number of tasks, while others remain idle, already having completed the work they were assigned. So, how do we evenly distribute tasks among processes?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;evenly-distributing-tasks-among-processes&quot;&gt;Evenly Distributing Tasks Among Processes&lt;&#x2F;h2&gt;
&lt;p&gt;When a process has run out of work to do, it should be able to acquire more work. To do this, it ‘steals’ work from sibling processes. This is known as a work-stealing synchronizer, and is used by languages like Go, Kotlin, and Rust (Tokio).&lt;&#x2F;p&gt;
&lt;p&gt;The way we’ll implement stealing is simple. When a task has run out of stuff to do, it selects a sibling at random, and attempts to steal half their tasks.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;time-is-short-savor-it&quot;&gt;Time is Short — Savor it&lt;&#x2F;h2&gt;
&lt;p&gt;But what if there are few tasks to steal? Processes shouldn’t waste CPU time trying to steal from others in vain. A processor with nothing better to do should do nothing. We’ll call the state of doing nothing &lt;em&gt;sleeping&lt;&#x2F;em&gt;. If a process attempts to steal from another awake process and finds nothing, it goes to sleep. If it is able to steal successfully, it tries to wake up a random process to further the distribution of work.&lt;&#x2F;p&gt;
&lt;p&gt;This wake-up&#x2F;sleep mechanism smoothly ramps the number of awake processes to match the computational workload.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-small-optimization&quot;&gt;A Small Optimization&lt;&#x2F;h2&gt;
&lt;p&gt;When a process spawns a new future, that future may immediately be ready to run. Processes don’t want to waste time cycling through waiting tasks in their queue. So, if a process spawns a new ready future, it stores it in a special ‘next’ slot, which it always checks before searching the queue. If there is already a task in the next slot, it is simply moved to the back of the queue. This ensures that the process almost always has access to a ready task, and doesn’t have to waste time searching.&lt;&#x2F;p&gt;
&lt;p&gt;Additionally, a processes queue may be completely full of waiting futures. If a process cycles through its entire queue and all futures are waiting, it goes to sleep. While asleep, the process can still be stolen from, it just prevents the process from cycling repeatedly, searching for a new task.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dataflow-analysis&quot;&gt;Dataflow Analysis&lt;&#x2F;h2&gt;
&lt;p&gt;Dataflow analysis is the act of building a graph of how data flows through a program. Traditionally, it has been used within the framework of compile time to determine the set of possible values that may be used at. However, dataflow analysis also determines which values are dependent on others. Asynchronously executing independent code can increase the speed at which certain series of operations can be done by parallelizing operations that can be done in parallel.&lt;&#x2F;p&gt;
&lt;p&gt;Instead of building a static external data-dependency graph, our above implementation intrinsically builds a graph of operations dynamically. In a sense, we store a slice of the graph at each moment in time, computing our way down the graph as time goes on.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;a-quick-summary-of-our-scheduler&quot;&gt;A Quick Summary of Our Scheduler&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;In short:&lt;&#x2F;strong&gt; A process can be searching for more tasks, running tasks from its own queue, or sleeping.&lt;&#x2F;p&gt;
&lt;p&gt;When a process is searching, it:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Selects a random sister process and tries to steal half her tasks.&lt;&#x2F;li&gt;
&lt;li&gt;If the sister has no tasks and is awake, the stealer goes to sleep.&lt;&#x2F;li&gt;
&lt;li&gt;If the stealer steals successfully, it tries to wake up another process at random.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;When a process is running, it:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Checks the next slot for a task.&lt;&#x2F;li&gt;
&lt;li&gt;If no task is found, it cycles through its futures queue until it finds a task.&lt;&#x2F;li&gt;
&lt;li&gt;If no futures are ready, it goes to sleep.&lt;&#x2F;li&gt;
&lt;li&gt;If the queue is empty, it starts searching.&lt;&#x2F;li&gt;
&lt;li&gt;Once a task has been found, it runs it.&lt;&#x2F;li&gt;
&lt;li&gt;Any new tasks created while running are pushed into the next slot, moving the previous task in that slot to the end of the queue.&lt;&#x2F;li&gt;
&lt;li&gt;Any new waiting futures are pushed to the end of the queue.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;When a process is sleeping:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;It waits to be woken up. It can still be stolen from, etc., but it isn’t doing anything.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h1 id=&quot;takeaway&quot;&gt;Takeaway&lt;&#x2F;h1&gt;
&lt;p&gt;Asynchronous programming will be a big deal in the years forward as we obtain access to more cores and reach the end of Moore’s law. By designing languages to be asynchronous-first, programmers can take advantage of the increased efficiency that they bring.&lt;&#x2F;p&gt;
&lt;p&gt;In this post, we discussed the design a simple &lt;em&gt;work-stealing scheduler&lt;&#x2F;em&gt; that limited synchronization and evenly distributed the workload among processes.&lt;&#x2F;p&gt;
&lt;p&gt;Asynchronous programming will be an interesting component of language design going forward, and it will be important for programmers to understand how to write asynchronous code. In Part II, we’ll implement the above schema.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>A Tiny Introduction to Parsers</title>
		<published>2020-07-08T00:00:00+00:00</published>
		<updated>2020-07-08T00:00:00+00:00</updated>
		<link rel="alternate" href="https://ehab-hassan.github.io/zola_test_new/blog/parser/" type="text/html"/>
		<id>https://ehab-hassan.github.io/zola_test_new/blog/parser/</id>
		<content type="html">&lt;h1 id=&quot;a-question&quot;&gt;A Question&lt;&#x2F;h1&gt;
&lt;p&gt;The other day, someone asked how parsers worked on The Programmer’s Hangout Discord server. Here’s an an abridged version of my explanation.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;my-response&quot;&gt;My Response&lt;&#x2F;h1&gt;
&lt;p&gt;A parser simply takes a stream of data and from it produces a datastructure. This stream is usually a stream of tokens, which are groups of tagged delimiters and data used to construct the datastructure.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s assume you’re building a parser for a programming language; the parser converts a file to an abstract syntax tree. We start with a file; in this case, it’s &lt;em&gt;AverageScript&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span&gt;for i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;print&lt;&#x2F;span&gt;&lt;span&gt;(i)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And lex it into a series of tokens by walking over the file linearly. So, for instance:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212121;color:#eeffff;&quot;&gt;&lt;code&gt;&lt;span&gt;for: keyword
&lt;&#x2F;span&gt;&lt;span&gt;i:   identifier
&lt;&#x2F;span&gt;&lt;span&gt;in:  keyword
&lt;&#x2F;span&gt;&lt;span&gt;[:   delimiter
&lt;&#x2F;span&gt;&lt;span&gt;1:   number
&lt;&#x2F;span&gt;&lt;span&gt;,:   separator
&lt;&#x2F;span&gt;&lt;span&gt;2:   number
&lt;&#x2F;span&gt;&lt;span&gt;     ... snip ...
&lt;&#x2F;span&gt;&lt;span&gt;}:   delimiter
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is the stream of tokens that will be fed into the parser to form the AST. So, how exactly does a parser work?&lt;&#x2F;p&gt;
&lt;p&gt;There are quite a few different kinds of parsers, but they all essentially reduce to the same set of steps:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Look at the next few tokens to determine what is being parsed&lt;&#x2F;li&gt;
&lt;li&gt;For each sub-section of what is being parsed, repeat this process.&lt;&#x2F;li&gt;
&lt;li&gt;Using this information, build the datastructure.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Most parsers are recursive for this reason; for example, in most languages, a function call can contain another function call:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#82aaff;&quot;&gt;bar&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of manually writing out cases for nesting, after we determine we’re looking at a function, we simply parse the contents of &lt;code&gt;foo(...)&lt;&#x2F;code&gt; according to some pre-defined rule.&lt;&#x2F;p&gt;
&lt;p&gt;So returning to our original case: how might a parser parse the &lt;code&gt;for i in ...&lt;&#x2F;code&gt;?&lt;&#x2F;p&gt;
&lt;p&gt;Assuming some form of a recursive descent parser:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;The parser sees &lt;code&gt;for&lt;&#x2F;code&gt; and determines a for loop is being parsed; In this made-up language, a for loop has three components, an identifier, an iterator, and a body.&lt;&#x2F;li&gt;
&lt;li&gt;It takes the next token, &lt;code&gt;i&lt;&#x2F;code&gt; and checks that it’s an identifier.&lt;&#x2F;li&gt;
&lt;li&gt;It takes the next token, &lt;code&gt;in&lt;&#x2F;code&gt; and makes sure it’s the in keyword.&lt;&#x2F;li&gt;
&lt;li&gt;It recursively evaluates the next series of tokens as an expression
&lt;ol&gt;
&lt;li&gt;It sees &lt;code&gt;[&lt;&#x2F;code&gt; so it starts parsing as a list&lt;&#x2F;li&gt;
&lt;li&gt;It sees &lt;code&gt;2&lt;&#x2F;code&gt; and adds it to said list&lt;&#x2F;li&gt;
&lt;li&gt;And so on until the entire list is parsed&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;It checks for &lt;code&gt;{&lt;&#x2F;code&gt; delimiting a for body&lt;&#x2F;li&gt;
&lt;li&gt;It recursively parses the next few tokens as a block of code
&lt;ol&gt;
&lt;li&gt;and so on until the entire code block is parsed&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;It checks for &lt;code&gt;}&lt;&#x2F;code&gt;, ending the for loop&lt;&#x2F;li&gt;
&lt;li&gt;It constructs a for node and returns it.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The end of this process might result in an AST that looks like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#212121;color:#eeffff;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;For &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    identifier&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; i&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    expression&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; List &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        items&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f78c6c;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;},
&lt;&#x2F;span&gt;&lt;span&gt;    body&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; Code &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        statements&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: [
&lt;&#x2F;span&gt;&lt;span&gt;            Function &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                identifier&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; print&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                arguments&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;: [&lt;&#x2F;span&gt;&lt;span&gt;i&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;},
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;},
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#89ddff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This AST can then be walked, interpreted, compiled, etc. There exist common formats to describe parsers; one such format is Extended Backus-Naur Form. Many parsing techniques exist; what I described models a LL(1) parser. Many parsing models exist; to learn more about them, I recommend you check the Parsing Wikipedia page.&lt;&#x2F;p&gt;
&lt;p&gt;So, to summarize:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;A parser takes a stream of data and builds a data-structure&lt;&#x2F;li&gt;
&lt;li&gt;Parsers generally work in a recursive manner by defining a set of rules that can be efficiently transversed.&lt;&#x2F;li&gt;
&lt;li&gt;Parsers can be formally described.&lt;&#x2F;li&gt;
&lt;li&gt;Many different parsing methods exist.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I hope this helped clear some things up 🙂.&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
